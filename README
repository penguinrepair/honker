"passion and purpose"
"i should be smart enough to do this on my own, as long as it is possible with the supplied sources...."

www.urbandictionary.com/define.php?term=honker

initial patch applied to the original x910-opensource-kernel to make comaptible(hopefully) with the x920

Only in .: aptus.initramfs.tar.gz
diff -r ./arch/arm/configs/vinsq_android_defconfig ../../qn_orig/Kernel//arch/arm/configs/vinsq_android_defconfig
67c67
< CONFIG_INITRAMFS_SOURCE="./initrd.arm.initramfs_list"
---
> CONFIG_INITRAMFS_SOURCE=""
diff -r ./arch/arm/mach-s3c6400/include/mach/instinctq.h ../../qn_orig/Kernel//arch/arm/mach-s3c6400/include/mach/instinctq.h
1c1,2
< /*  linux/include/asm-arm/arch-s3c2410/instinctq.h
---
> /*
>  *  linux/include/asm-arm/arch-s3c2410/instinctq.h
9c10,11
<  *  published by the Free Software Foundation. */
---
>  *  published by the Free Software Foundation.
>  */
11a14
> 
12a16
> 
15c19,21
< /* Board Configuration */
---
> /* 
>  * Board Configuration
>  */
34c40
< // rev01: 4096(12bit) * 15/(100+15) = 534
---
> // rev01: 4096(12bit) * 15/(100+15) = 534 
38c44
< // rev01a: 4096(12bit) * 15/(68+15) = 740
---
> // rev01a: 4096(12bit) * 15/(68+15) = 740 
42c48
< // rev02: 4096(12bit) * 22/(68+22) = 1001
---
> // rev02: 4096(12bit) * 22/(68+22) = 1001 
46c52
< // rev03: 4096(12bit) * 22/(47+22) = 1305
---
> // rev03: 4096(12bit) * 22/(47+22) = 1305 
50c56
< // rev04: 4096(12bit) * 27/(47+27) = 1494
---
> // rev04: 4096(12bit) * 27/(47+27) = 1494 
52c58
< #define REVISION_ADC_REV04_MIN  	220
---
> #define REVISION_ADC_REV04_MIN		220	
69c75
< // rev01: 4096(12bit) * 15/(100+15) = 534
---
> // rev01: 4096(12bit) * 15/(100+15) = 534 
73c79
< // rev01a: 4096(12bit) * 15/(68+15) = 740
---
> // rev01a: 4096(12bit) * 15/(68+15) = 740 
77c83
< // rev02: 4096(12bit) * 22/(68+22) = 1001
---
> // rev02: 4096(12bit) * 22/(68+22) = 1001 
81c87
< // rev03: 4096(12bit) * 22/(47+22) = 1305
---
> // rev03: 4096(12bit) * 22/(47+22) = 1305 
85c91,92
< // rev04: 4096(12bit) * 27/(47+27) = 1494
---
> // rev04: 4096(12bit) * 27/(47+27) = 1494 
> 
126c133
< 	gpio_free(GPIO_MCAM_RST_N);	\
---
> 	gpio_free(GPIO_MCAM_RST_N);	\		
131c138
< 	gpio_free(GPIO_MCAM_RST_N);	\
---
> 	gpio_free(GPIO_MCAM_RST_N);	\	
142c149
< 	gpio_free(GPIO_SCAM_RST_N); \
---
> 	gpio_free(GPIO_SCAM_RST_N); \			
146,147c153,154
< 	gpio_direction_output(GPIO_SCAM_RST_N, GPIO_LEVEL_HIGH);	\
< 	gpio_free(GPIO_SCAM_RST_N);	\
---
> 	gpio_direction_output(GPIO_SCAM_RST_N, GPIO_LEVEL_HIGH);	\     
> 	gpio_free(GPIO_SCAM_RST_N);	\			
167c174
< 	gpio_free(GPIO_CAM_EN);	\
---
> 	gpio_free(GPIO_CAM_EN);	\	
173c180
< 	gpio_free(GPIO_CAM_STANDBY);	\
---
> 	gpio_free(GPIO_CAM_STANDBY);	\		
184c191
< 	gpio_free(GPIO_CAM_STANDBY);	\
---
> 	gpio_free(GPIO_CAM_STANDBY);	\	
191c198
< 	gpio_free(GPIO_SCAM_STANDBY);	\
---
> 	gpio_free(GPIO_SCAM_STANDBY);	\		
202c209
< 	gpio_free(GPIO_SCAM_STANDBY); \
---
> 	gpio_free(GPIO_SCAM_STANDBY); \				
214c221
< #define S5K4CA_ID	0x78
---
> #define S5K4CA_ID	0x78 
248a256
> 
diff -r ./arch/arm/mach-s3c6410/mach-instinctq.c ../../qn_orig/Kernel//arch/arm/mach-s3c6410/mach-instinctq.c
10c10,12
<  * published by the Free Software Foundation. */
---
>  * published by the Free Software Foundation.
>  *
> */
92a95
> 
135c138
< 	.udelay			= 2,	/* 250KHz */
---
> 	.udelay			= 2,	/* 250KHz */		
150c153
< 	.udelay			= 2,	/* 250KHz */
---
> 	.udelay			= 2,	/* 250KHz */		
166c169
< 	.udelay			= 2,	/* 250KHz */
---
> 	.udelay			= 2,	/* 250KHz */		
183c186
< 	.udelay			= 3,	/* 166KHz */
---
> 	.udelay			= 3,	/* 166KHz */		
199c202
< 	.udelay			= 3,	/* 250KHz->166 from 2->3 */
---
> 	.udelay			= 3,	/* 250KHz->166 from 2->3 */		
221c224
< 	.udelay			= 3,	/* 166KHz */
---
> 	.udelay			= 3,	/* 166KHz */		
237c240
< 	.udelay			= 2,	/* 250KHz */
---
> 	.udelay			= 2,	/* 250KHz */		
315c318
< 	{
---
> 	{ 
319c322
< 	{
---
> 	{ 
353,355c356,358
< 			.eint		= IRQ_EINT(10),
< 			.gpio		= GPIO_DET_35,
< 			.gpio_af	= GPIO_DET_35_AF  ,
---
> 			.eint		= IRQ_EINT(10), 
> 			.gpio		= GPIO_DET_35,   
> 			.gpio_af	= GPIO_DET_35_AF  , 
359,361c362,364
< 			.eint		= IRQ_EINT(11),
< 			.gpio		= GPIO_EAR_SEND_END,
< 			.gpio_af	= GPIO_EAR_SEND_END_AF,
---
> 			.eint		= IRQ_EINT(11), 
> 			.gpio		= GPIO_EAR_SEND_END, 
> 			.gpio_af	= GPIO_EAR_SEND_END_AF, 
366,368c369,371
< 			.eint		= IRQ_EINT(21),
< 			.gpio		= GPIO_MONOHEAD_DET_ISR,
< 			.gpio_af	= GPIO_MONOHEAD_DET_ISR_AF  ,
---
> 			.eint		= IRQ_EINT(21), 
> 			.gpio		= GPIO_MONOHEAD_DET_ISR,   
> 			.gpio_af	= GPIO_MONOHEAD_DET_ISR_AF  , 
371c374
< #endif
---
> #endif		
374,376c377,379
< 			.eint		= IRQ_EINT(21),
< 			.gpio		= GPIO_MONOHEAD_DET,
< 			.gpio_af	= GPIO_MONOHEAD_DET_AF,
---
> 			.eint		= IRQ_EINT(21), 
> 			.gpio		= GPIO_MONOHEAD_DET, 
> 			.gpio_af	= GPIO_MONOHEAD_DET_AF, 
382c385
< 
---
>  
398a402,403
> 	.pmem_gpu1_start = GPU1_RESERVED_PMEM_START,
> 	.pmem_gpu1_size = RESERVED_PMEM_GPU1,
467c472
< #else
---
> #else	
577c582
< #ifndef CONFIG_MACH_MAX
---
> #ifndef CONFIG_MACH_MAX	
601c606
< #else
---
> #else	
708a714
> 	
733,735c739,741
< static void instinctq_set_qos(void)
< {
< 	u32 reg;     							 /* AXI sfr */
---
> static void instinctq_set_qos(void) 
> {     
> 	u32 reg;     							 /* AXI sfr */     
744c750
< }
---
> } 
746c752,754
< /*	Power Off Handler */
---
> /*
>  *	Power Off Handler
>  */
777c785
< #endif
---
> #endif 
800c808
< 				if (gpio_request(GPIO_POWER_N, S3C_GPIO_LAVEL(GPIO_POWER_N)))
---
> 				if (gpio_request(GPIO_POWER_N, S3C_GPIO_LAVEL(GPIO_POWER_N))) 
806c814
< 				if (gpio_request(GPIO_PHONE_ACTIVE, S3C_GPIO_LAVEL(GPIO_PHONE_ACTIVE)))
---
> 				if (gpio_request(GPIO_PHONE_ACTIVE, S3C_GPIO_LAVEL(GPIO_PHONE_ACTIVE))) 
814c822
< 				while (!gpio_get_value(GPIO_POWER_N));
---
> 				while (!gpio_get_value(GPIO_POWER_N)); 
826c834
< 				}
---
> 				}	
832c840
< 				if (gpio_request(GPIO_PDA_PS_HOLD, S3C_GPIO_LAVEL(GPIO_PDA_PS_HOLD)))
---
> 				if (gpio_request(GPIO_PDA_PS_HOLD, S3C_GPIO_LAVEL(GPIO_PDA_PS_HOLD))) 
849c857
< {
---
> {	
859,861c867,869
< 	if ( uart_current_owner )
< 		return sprintf(buf, "%s[UART Switch] Current UART owner = PDA \n", buf);
< 	else
---
> 	if ( uart_current_owner )		
> 		return sprintf(buf, "%s[UART Switch] Current UART owner = PDA \n", buf);	
> 	else			
866c874
< {
---
> {	
872,874c880,882
< 	if (strncmp(buf, "PDA", 3) == 0 || strncmp(buf, "pda", 3) == 0)	{
< 		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_HIGH);
< 		uart_current_owner = 1;
---
> 	if (strncmp(buf, "PDA", 3) == 0 || strncmp(buf, "pda", 3) == 0)	{		
> 		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_HIGH);		
> 		uart_current_owner = 1;		
876,877c884,885
< 		printk("[UART Switch] Path : PDA\n");
< 	}
---
> 		printk("[UART Switch] Path : PDA\n");	
> 	}	
879,881c887,889
< 	if (strncmp(buf, "MODEM", 5) == 0 || strncmp(buf, "modem", 5) == 0) {
< 		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_LOW);
< 		uart_current_owner = 0;
---
> 	if (strncmp(buf, "MODEM", 5) == 0 || strncmp(buf, "modem", 5) == 0) {		
> 		gpio_set_value(GPIO_UART_SEL, GPIO_LEVEL_LOW);		
> 		uart_current_owner = 0;		
883,884c891,892
< 		printk("[UART Switch] Path : MODEM\n");
< 	}
---
> 		printk("[UART Switch] Path : MODEM\n");	
> 	}	
905c913
< #ifdef CONFIG_KERNEL_DEBUG_SEC
---
> #ifdef CONFIG_KERNEL_DEBUG_SEC 
911c919
< 		else if (!strcmp((char *)_cmd, "download"))
---
> 		else if (!strcmp((char *)_cmd, "download")) 
915c923
< #ifdef CONFIG_KERNEL_DEBUG_SEC
---
> #ifdef CONFIG_KERNEL_DEBUG_SEC 
918c926
< 		else if (!strcmp((char *)_cmd, "factory_reboot")) {
---
> 		else if (!strcmp((char *)_cmd, "factory_reboot")) { 
922c930
< #endif
---
> #endif		
927c935
< 
---
> 	
946c954
< 		if (gpio_request(GPIO_UART_SEL, S3C_GPIO_LAVEL(GPIO_UART_SEL)))
---
> 		if (gpio_request(GPIO_UART_SEL, S3C_GPIO_LAVEL(GPIO_UART_SEL))) 
960c968
< 
---
> 	
965c973
< 		if (gpio_request(GPIO_VIB_EN, S3C_GPIO_LAVEL(GPIO_VIB_EN)))
---
> 		if (gpio_request(GPIO_VIB_EN, S3C_GPIO_LAVEL(GPIO_VIB_EN))) 
985c993
< 
---
> 	
1009c1017
< #endif
---
> #endif    
1013c1021
< #endif
---
> #endif	
1025a1034
> 
1220c1229
< 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
1236,1239c1245,1248
< 	{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_CS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_CS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1280c1289
< 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1283c1292
< 	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1363c1372
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1366c1375
< 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1397c1406
< 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
1413,1416c1422,1425
< 	{ GPIO_SCAM_RST_N, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
< 	{ GPIO_SCAM_STANDBY, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
< 	{ GPIO_LCD_BL_SCL_N, GPIO_LCD_BL_SCL_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_LCD_BL_SDA_N, GPIO_LCD_BL_SDA_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_SCAM_RST_N, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
> 	{ GPIO_SCAM_STANDBY, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
> 	{ GPIO_LCD_BL_SCL_N, GPIO_LCD_BL_SCL_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_LCD_BL_SDA_N, GPIO_LCD_BL_SDA_N_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1457c1466
< 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1460c1469
< //	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> //	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1540c1549
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1543c1552
< 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1574c1583
< 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SENSOR_SDA, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
1590,1592c1599,1601
< 	//{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	//{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	//{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	//{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	//{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	//{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1634c1643
< 	//{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	//{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1636,1637c1645,1646
< 	//{ GPIO_MAIN_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
< 	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	//{ GPIO_MAIN_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
> 	{ GPIO_LCD_BL_SEL, 1, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1717c1726
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1719c1728
< 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1768c1777
< 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1810c1819
< 	/* GPH */
---
> 	/* GPH */	
1812c1821
< 	{ GPIO_WLAN_CMD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_WLAN_CMD, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_NONE },	
1827c1836
< 	{ GPIO_LCD_B_5, GPIO_LCD_B_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_LCD_B_5, GPIO_LCD_B_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1833c1842
< 	{ GPIO_LCD_G_5, GPIO_LCD_G_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_LCD_G_5, GPIO_LCD_G_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1841c1850
< 	{ GPIO_LCD_R_5, GPIO_LCD_R_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_LCD_R_5, GPIO_LCD_R_5_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1848c1857
< 	{ GPIO_CHG_EN, GPIO_CHG_EN_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_CHG_EN, GPIO_CHG_EN_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1854c1863
< 	{ GPIO_TOUCH_RST, GPIO_TOUCH_RST_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, //quattro.tsp
---
> 	{ GPIO_TOUCH_RST, GPIO_TOUCH_RST_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, //quattro.tsp	
1863c1872
< 	{ GPIO_KEYSENSE_6, GPIO_KEYSENSE_6_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_KEYSENSE_6, GPIO_KEYSENSE_6_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },	
1883c1892
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
1889c1898
< 	{ GPIO_DET_35, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_DET_35, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },	
1895c1904
< 	{ GPIO_TOUCH_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 }, //quattro.tsp
---
> 	{ GPIO_TOUCH_INT_N, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 }, //quattro.tsp	
1937,1940c1946,1949
< 	{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
< 	{ GPIO_OJ_CS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_OJ_SPI_MISO, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_SPI_CLK, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_SPI_MOSI, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
> 	{ GPIO_OJ_CS, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
1981c1990
< 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_SUB_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
1983c1992
< 	{ GPIO_MAIN_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },
---
> 	{ GPIO_MAIN_KEY_LED_EN, 1, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, S3C_GPIO_SLP_OUT0, S3C_GPIO_PULL_NONE },	
2025c2034
< 	{ GPIO_CHG_EN, GPIO_CHG_EN_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_CHG_EN, GPIO_CHG_EN_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
2060c2069
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
2062,2063c2071,2072
< 	{ GPIO_OJ_MOTION, GPIO_OJ_MOTION_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 },
< 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_OJ_MOTION, GPIO_OJ_MOTION_AF, GPIO_LEVEL_NONE, S3C_GPIO_PULL_NONE, 0, 0 }, 
> 	{ GPIO_MSENSE_RST_N, GPIO_MSENSE_RST_N_AF, GPIO_LEVEL_HIGH, S3C_GPIO_PULL_NONE, 0, 0 }, 
2098c2107
< 			pr_debug("%s: Off gpio=%d,%d\n", __func__, gpio,
---
> 			pr_debug("%s: Off gpio=%d,%d\n", __func__, gpio, 
2135c2144
< 
---
> 	
2137c2146
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");			
2146c2155
< 			}
---
> 			}		
2150c2159
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");			
2159c2168
< 			}
---
> 			}		
2162c2171
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU, gpxconslp 0,1:Output 2:input, gpxpudslp 1:PD 2:PU\n");			
2176c2185
< 			}
---
> 			}		
2179c2188
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");			
2189c2198
< 				gpxpud[i] = ((__raw_readl(gpio_bank+0x0C))&(0x3<<(2*i))>>(2*i))&0x3;
---
> 				gpxpud[i] = ((__raw_readl(gpio_bank+0x0C))&(0x3<<(2*i))>>(2*i))&0x3;				
2191c2200
< 			}
---
> 			}		
2194c2203
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");			
2199c2208
< 				gpxpud[i] = (__raw_readl(gpio_bank+0x08))&(0x3<<(2*i))>>(2*i);
---
> 				gpxpud[i] = (__raw_readl(gpio_bank+0x08))&(0x3<<(2*i))>>(2*i);				
2201c2210
< 			}
---
> 			}		
2204c2213
< 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");
---
> 		printk("gpxcon 0:input 1:output, gpxdat:, gpxpud 1:PD 2:PU\n");			
2209c2218
< 				gpxpud[i] = ((__raw_readl(gpio_bank+0x08))&(0x3<<(2*i))>>(2*i))&0x3;
---
> 				gpxpud[i] = ((__raw_readl(gpio_bank+0x08))&(0x3<<(2*i))>>(2*i))&0x3;				
2211c2220
< 			}
---
> 			}		
2232c2241
<     printk("===========GPH==========\n");
---
> 	printk("===========GPH==========\n");
2246c2255
<     printk("===========GPO==========\n");
---
> 	printk("===========GPO==========\n");
2250c2259
<     printk("===========GPQ==========\n");
---
> 	printk("===========GPQ==========\n");
2280c2289
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
2310c2319
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
2325c2334
< 	{ GPIO_PWM1_TOUT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },
---
> 	{ GPIO_PWM1_TOUT, 0, GPIO_LEVEL_NONE, S3C_GPIO_PULL_DOWN, S3C_GPIO_SLP_INPUT, S3C_GPIO_PULL_DOWN },	
2342c2351
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
2375c2384
< 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 },
---
> 	{ GPIO_PDA_ACTIVE, GPIO_PDA_ACTIVE_AF, GPIO_LEVEL_LOW, S3C_GPIO_PULL_NONE, 0, 0 }, 
2391c2400
< 
---
> 	
2425c2434
< {
---
> {	
2440c2449
< 	__raw_writel(0x10055000, S3C64XX_MEM1CONSLP);
---
> 	__raw_writel(0x10055000, S3C64XX_MEM1CONSLP);	
2467c2476
< 	/* Wake-up source
---
> 	/* Wake-up source 
2475c2484
< 	//register INTB(EINT9) with wakeup source
---
> 	//register INTB(EINT9) with wakeup source 
2477a2487
> 	
2482c2492
<     	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>     	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2488c2498
<         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2491c2501
< 			eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
> 			eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2494c2504
< 
---
> 	
2501c2511
<         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2504c2514
< 			eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
> 			eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2509,2510c2519,2520
<         if(get_headset_status()==0)//hw bug
< 	    	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>         if(get_headset_status()==0)//hw bug    
> 	    	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2513,2514c2523,2524
< 	    	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
< 			(0x1 << 11) | (0x1 << 10) | (0x1 << 9) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (0x1 << 1) |  0x1;
---
> 	    	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
> 			(0x1 << 11) | (0x1 << 10) | (0x1 << 9) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (0x1 << 1) |  0x1;		
2516c2526
< 
---
>     	
2524c2534
<                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2530c2540
<                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2535c2545
<         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>         	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2539c2549
<     	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>     	eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2547c2557
<     	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
>     	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2553c2563
<         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
>         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2556c2566
< 			eint0pend_val = (0x1 << 25) | (0x1 << 22) |(0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
> 			eint0pend_val = (0x1 << 25) | (0x1 << 22) |(0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2566c2576
<         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
>         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2569c2579
< 			eint0pend_val = (0x1 << 25) | (0x1 << 22) |(0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
> 			eint0pend_val = (0x1 << 25) | (0x1 << 22) |(0x1 << 21) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2575c2585
< 		   	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
> 		   	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2577,2578c2587,2588
< 		else
< 		   	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
> 		else			
> 		   	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
2582c2592
< 
---
>     
2590c2600
<                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2596c2606
<                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) |
---
>                 eint0pend_val |= (0x1 << 25) | (0x1 << 22) |(0x1 << 21) |(0x1 << 20) |  (0x1 << 19) | (0x1 << 12) | 
2601,2602c2611,2612
<         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
<     		(0x1 << 11) | (0x1 << 10) | (0x1 << 9) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (0x1 << 1) | 0x1;
---
>         	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
>     		(0x1 << 11) | (0x1 << 10) | (0x1 << 9) | (0x1 << 6) | (0x1 << 5) | (0x1 << 4) | (0x1 << 1) | 0x1;	
2605c2615
<     	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) |
---
>     	eint0pend_val = (0x1 << 25) | (0x1 << 22) | (0x1 << 20) | (0x1 << 19) | (0x1 << 12) | 
diff -r ./arch/arm/plat-s3c64xx/devs.c ../../qn_orig/Kernel//arch/arm/plat-s3c64xx/devs.c
597a598,603
> 
> static struct android_pmem_platform_data pmem_gpu1_pdata = {
> 	.name 		= "pmem_gpu1",
> 	.cached 	= 1,
> 	.buffered 	= 1,
> };
640c646,652
<  
---
> 
> static struct platform_device pmem_gpu1_device = {
> 	.name		= "android_pmem",
> 	.id 		= 1,
> 	.dev		= { .platform_data = &pmem_gpu1_pdata },
> };
>   
682a695,700
> 	}
> 
> 	if (setting->pmem_gpu1_size) {
> 		pmem_gpu1_pdata.start = setting->pmem_gpu1_start;
> 		pmem_gpu1_pdata.size = setting->pmem_gpu1_size;
> 		platform_device_register(&pmem_gpu1_device);
diff -r ./arch/arm/plat-s3c64xx/include/plat/reserved_mem.h ../../qn_orig/Kernel//arch/arm/plat-s3c64xx/include/plat/reserved_mem.h
45a46
> #define RESERVED_PMEM_GPU1		(RESERVED_G3D)
60c61,62
< #define G3D_RESERVED_START			(RESERVED_PMEM_END_ADDR - RESERVED_G3D)		 /* G3D is shared */
---
> #define G3D_RESERVED_START		(RESERVED_PMEM_END_ADDR - RESERVED_G3D)		 /* G3D is shared */
> #define GPU1_RESERVED_PMEM_START	(G3D_RESERVED_START)
71a74,75
> 	resource_size_t pmem_gpu1_start;
> 	resource_size_t pmem_gpu1_size;
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g2d: g2d_regs.h
diff -r ./drivers/media/s3c6410/g2d/Kconfig ../../qn_orig/Kernel//drivers/media/s3c6410/g2d/Kconfig
5c5
< ##menu "G2D Support"
---
> menu "G2D Support"
8c8
<     bool "Samsung FIMG-2D Driver"
---
>     bool "FIMG-2D Driver"
13c13
< #endmenu
---
> endmenu
diff -r ./drivers/media/s3c6410/g2d/Makefile ../../qn_orig/Kernel//drivers/media/s3c6410/g2d/Makefile
7c7
< obj-$(CONFIG_VIDEO_G2D)       += s3c_g2d_driver.o
---
> obj-$(CONFIG_VIDEO_G2D)       += s3c_g2d.o
Only in ./drivers/media/s3c6410/g2d: regs_s3c_g2d.h
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g2d: s3c_g2d.c
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g2d: s3c_g2d.c_orig
Only in ./drivers/media/s3c6410/g2d: s3c_g2d_driver.c
Only in ./drivers/media/s3c6410/g2d: s3c_g2d_driver.h
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g2d: s3c_g2d.h
Only in ../../qn_orig/Kernel//drivers/media/s3c6410: g2d_samsung
diff -r ./drivers/media/s3c6410/g3d/Kconfig ../../qn_orig/Kernel//drivers/media/s3c6410/g3d/Kconfig
2,3c2
< ## G2D subsystem configuration
< ##
---
> # G3D subsystem configuration
5c4,5
< ##menu "G2D Support"
---
> 
> menu "G3D Support"
8,10c8,10
<     bool	"Samsung FIMG-3D Driver"
<     depends on CPU_S3C6410
<     default n
---
> 	tristate "OpenFIMG FIMG-3DSE Driver"
> #	bool "Samsung FIMG-3DSE Driver"
> 	default n
12,13c12,15
< 	    FIMG-3D
< #endmenu
---
> 		FIMG-3D
> 
> endmenu
> 
diff -r ./drivers/media/s3c6410/g3d/s3c_g3d.c ../../qn_orig/Kernel//drivers/media/s3c6410/g3d/s3c_g3d.c
3c3
<  * Copyright (c) 2008 Samsung Electronics
---
>  * Copyright (c) 2010 Tomasz Figa <tomasz.figa at gmail.com>
22,30d21
< #include <linux/init.h>
< #include <linux/module.h>
< #include <linux/moduleparam.h>
< #include <linux/types.h>
< #include <linux/timer.h>
< #include <linux/kernel.h>
< #include <linux/fs.h>
< #include <linux/platform_device.h>
< #include <linux/interrupt.h>
31a23
> #include <linux/completion.h>
33,41c25,29
< #include <linux/sched.h>
< #include <asm/uaccess.h>
< #include <linux/errno.h> 	/* error codes */
< #include <asm/div64.h>
< #include <linux/mm.h>
< #include <linux/tty.h>
< #include <asm/io.h>
< #include <asm/irq.h>
< #include <asm/uaccess.h>
---
> #include <linux/fs.h>
> #include <linux/hrtimer.h>
> #include <linux/interrupt.h>
> #include <linux/io.h>
> #include <linux/irq.h>
43,51c31,36
< #include <linux/mman.h>
< 
< #include <linux/unistd.h>
< 
< #include <linux/version.h>
< #include <asm/dma.h>
< #include <asm/cacheflush.h>
< #include <linux/dma-mapping.h>
< #include <linux/vmalloc.h>
---
> #include <linux/mm.h>
> #include <linux/platform_device.h>
> #include <linux/poll.h>
> #include <linux/sched.h>
> #include <linux/uaccess.h>
> #include <linux/workqueue.h>
53d37
< #include <mach/dma.h>
56,57d39
< #include <plat/dma.h>
< #include <plat/pm.h>
59,63c41
< #include <plat/reserved_mem.h>
< 
< #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
< 
< #ifdef CONFIG_PLAT_S3C64XX
---
> #include <plat/pm.h>
64a43
> #include <plat/reserved_mem.h>
66,67c45
< #define S3C_G3D_PA 	(0x72000000)
< #define S3C_G3D_IRQ (IRQ_S3C6410_G3D)
---
> #include "s3c_g3d.h"
70,98d47
< //#define USE_G3D_DOMAIN_GATING
< #endif /* CONFIG_S3C64XX_DOMAIN_GATING */
< 
< #define DOMAIN_POWER_ON do { \
< 	s3c_set_normal_cfg(S3C64XX_DOMAIN_G, S3C64XX_ACTIVE_MODE, S3C64XX_3D); \
< 	if(s3c_wait_blk_pwr_ready(S3C64XX_BLK_G)) { \
< 		return -1; \
< 	} \
< } while (0)
< 
< #define DOMAIN_POWER_OFF do { \
< 	s3c_set_normal_cfg(S3C64XX_DOMAIN_G, S3C64XX_LP_MODE, S3C64XX_3D); \
< } while (0)
< 
< #define IS_DOMAIN_POWER_OFF domain_off_check(S3C64XX_DOMAIN_G)
< 
< #else
< #ifdef CONFIG_PLAT_S5PC1XX
< #define S3C_G3D_PA 	(0xEF000000)
< #define S3C_G3D_IRQ (IRQ_3D)
< 
< #else
< #ifdef CONFIG_PLAT_S5P64XX
< #include <plat/power_clk_gating.h>
< 
< #define S3C_G3D_PA 	(0xD8000000)
< #define S3C_G3D_IRQ (IRQ_3D)
< 
< #ifdef S5P6442_POWER_GATING_G3D
100,141c49
< #endif /* S5P6442_POWER_GATING_G3D */
< 
< #define DOMAIN_POWER_ON do { \
< 	s5p6442_pwrgate_config(S5P6442_G3D_ID, S5P6442_ACTIVE_MODE); \
< } while (0)
< 
< #define DOMAIN_POWER_OFF do { \
< 	s5p6442_pwrgate_config(S5P6442_G3D_ID, S5P6442_LP_MODE); \
< } while (0)
< 
< #define IS_DOMAIN_POWER_OFF !s5p6442_blkpower_state(S5P6442_G3D_ID)
< 
< #else
< #error Unsupported platfotm
< 
< #endif /* CONFIG_PLAT_S5P6442 */
< #endif /* CONFIG_PLAT_S5PC1XX */
< #endif /* CONFIG_PLAT_S3C64XX */
< 
< #else
< 
< #ifdef CONFIG_PLAT_S3C64XX
< #define S3C_G3D_PA 	(0x72000000)
< #define S3C_G3D_IRQ (IRQ_3D)
< 
< #else
< #ifdef CONFIG_PLAT_S5PC1XX
< #define S3C_G3D_PA 	(0xEF000000)
< #define S3C_G3D_IRQ (IRQ_3D)
< 
< #else
< #ifdef CONFIG_CPU_S5P6442
< // 6442 will be supported from 2.6.29 kernel
< #error Unsupported platfotm
< 
< #else
< #error Unsupported platfotm
< #endif /* CONFIG_PLAT_S5P6442 */
< #endif /* CONFIG_PLAT_S5PC1XX */
< #endif /* CONFIG_PLAT_S3C64XX */
< 
< #endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,8,0)
---
> #endif
143c51,53
< unsigned long long g_uiFreeMemMap = 0x0;
---
> /* Driver information */
> #define DRIVER_DESC		"S3C G3D Device Driver"
> #define DRIVER_NAME		"s3c-g3d"
145c55,92
< #define S3C6410_SZ_G3D 		SZ_4K
---
> /* Various definitions */
> #define G3D_MINOR  		249
> #define G3D_SFR_BASE		0x72000000
> #define G3D_SFR_SIZE		0x80000
> #define G3D_IDLE_TIME_SECS	10
> #define G3D_TIMEOUT		1000
> 
> /* Registers */
> #define G3D_FGGB_PIPESTAT_REG		(0x00)
> #define G3D_FGGB_CACHECTL_REG		(0x04)
> #define G3D_FGGB_RESET_REG		(0x08)
> #define G3D_FGGB_VERSION		(0x10)
> #define G3D_FGGB_INTPENDING_REG		(0x40)
> #define G3D_FGGB_INTMASK_REG		(0x44)
> #define G3D_FGGB_PIPEMASK_REG		(0x48)
> #define G3D_FGGB_PIPETGTSTATE_REG	(0x4c)
> 
> /* Valid bits of FGGB_PIPESTAT */
> #define G3D_FGGB_PIPESTAT_MSK	(0x0005171f)
> #define G3D_FGGB_FLUSH_MSK	(0x00000033)
> #define G3D_FGGB_INVAL_MSK	(0x00001300)
> 
> struct g3d_context;
> 
> /* Driver data (shared) */
> struct g3d_drvdata {
> 	void __iomem		*base;	// registers base address
> 
> 	uint32_t		mask;
> 	struct mutex		lock;	// mutex
> 	struct mutex		hw_lock; 
> 	struct g3d_context	*owner; // current context
> 	struct completion	completion; // completion
> 
> 	int			irq;	// interrupt number
> 	struct resource 	*mem;	// memory resource
> 	struct clk		*clock;	// device clock
> 	struct device		*dev;
147,148c94,103
< #define DEBUG_S3C_G3D
< #undef	DEBUG_S3C_G3D
---
> #ifdef USE_G3D_DOMAIN_GATING
> 	struct hrtimer		timer;	// idle timer
> 	int			state;	// power state
> #endif
> };
> struct g3d_drvdata	*drvdata;
> struct g3d_context {
> 	struct g3d_drvdata	*data;
> 	/* More to come */
> };
150,151c105,109
< #ifdef DEBUG_S3C_G3D
< #define DEBUG(fmt,args...) printk(fmt, ##args)
---
> /* Logging */
> //#define G3D_DEBUG
> #ifdef G3D_DEBUG
> #define DBG(format, args...) \
> 	printk(KERN_DEBUG "%s: " format, DRIVER_NAME, ## args)
153c111
< #define DEBUG(fmt,args...) do {} while(0)
---
> #define DBG(format, args...)
154a113,118
> #define ERR(format, args...) \
> 	printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
> #define WARNING(format, args...) \
> 	printk(KERN_WARNING "%s: " format, DRIVER_NAME, ## args)
> #define INFO(format, args...) \
> 	printk(KERN_INFO "%s: " format, DRIVER_NAME, ## args)
156,170c120,122
< #define G3D_RESERVED_MEM_ADDR_PHY	G3D_RESERVED_START
< #define G3D_RESERVED_MEM_SIZE		RESERVED_G3D
< 
< #define G3D_CHUNK_SIZE SZ_1M  //SZ_4M
< 
< #define G3D_UI_CHUNK_NUM		(RESERVED_G3D_UI / G3D_CHUNK_SIZE)
< 
< static int G3D_CHUNK_NUM = -1;
< 
< typedef struct __alloc_info {
< 	unsigned int    file_desc_id;
< 	struct pid *    pId;
< 	u64 	uiAllocedMemMap;
< 	struct __alloc_info	*next;
< } alloc_info;
---
> /*
> 	Register accessors
> */
172,175c124
< alloc_info *alloc_info_head = NULL;
< alloc_info *alloc_info_tail = NULL;
< 
< void g3d_alloc_info_dump(void)
---
> static inline void g3d_write(struct g3d_drvdata *d, uint32_t b, uint32_t r)
177,191c126
< 	alloc_info *i=alloc_info_head;
< 	int j;
< 
< 	printk("g3d_alloc_info_dump\n");
< 	while(i)
< 	{
< 		printk("(ID:0x%x) ",i->file_desc_id);
< 		for(j=0;j<G3D_CHUNK_NUM;j++)
< 			if(i->uiAllocedMemMap&(1<<j)) printk("1");
< 			else printk("0");
< 		i=i->next;
< 		if(i) printk(" ->");
< 	}
< 	printk("\n");
< 	if(alloc_info_tail) printk("alloc_info_tail = (ID:0x%x) \n",alloc_info_tail->file_desc_id);
---
> 	writel(b, d->base + r);
194c129
< static void* Malloc_3D_ChunkMem(unsigned int szReq, int ithMem)
---
> static inline uint32_t g3d_read(struct g3d_drvdata *d, uint32_t r)
196,201c131
< 	unsigned long physicAddr = (G3D_RESERVED_MEM_ADDR_PHY) + (G3D_CHUNK_SIZE * ithMem);
< 	void * virtAddr = phys_to_virt((unsigned long)physicAddr);
< 
< 	g_uiFreeMemMap |=(0x1 << ithMem);
< 
< 	return virtAddr;
---
> 	return readl(d->base + r);
204c134,138
< static void Free_3D_ChunkMem(void* virtAddr,  int ithMem)
---
> /*
> 	Hardware operations
> */
> 
> static inline void g3d_soft_reset(struct g3d_drvdata *data)
206c140,142
< 	g_uiFreeMemMap &=~(0x1 << ithMem);
---
> 	g3d_write(data, 1, G3D_FGGB_RESET_REG);
> 	udelay(1);
> 	g3d_write(data, 0, G3D_FGGB_RESET_REG);
209,340c145
< #define G3D_CHUCNK_AVALIABLE	0
< #define G3D_CHUCNK_RESERVED		1
< 
< #define TIMER_INTERVAL HZ  //HZ/4
< 
< typedef struct {
< 	int		size;
< 	unsigned int 	vir_addr;
< 	unsigned int 	phy_addr;
< 	unsigned int 	in_used;	/* 0 means avaliable, 1 means reserved */
< 	unsigned int    file_desc_id;
< } s3c_g3d_bootmem;
< 
< s3c_g3d_bootmem *g3d_bootm = NULL;// [G3D_CHUNK_NUM];
< 
< typedef struct{
< 	unsigned int pool_buffer_addr;
< 	unsigned int pool_buffer_size;
< 	unsigned int hardware_has_single_pipeline;
< 	unsigned int is_dma_available;
< 	unsigned int dma_buffer_addr;
< 	unsigned int dma_buffer_size;
< } G3D_CONFIG_STRUCT;
< 
< typedef struct{
< 	unsigned int offset; 	// should be word aligned
< 	unsigned int size; 	// byte size, should be word aligned
< } DMA_BLOCK_STRUCT;
< 
< typedef struct {
< 	ulong src;
< 	ulong dst;
< 	int len;
< } s3c_3d_dma_info;
< 
< #ifdef USE_G3D_DOMAIN_GATING
< struct timer_list       g3d_pm_timer;
< #endif /* USE_G3D_DOMAIN_GATING */
< 
< #define FGGB_PIPESTATE		0x00
< #define FGGB_CACHECTL		0x04
< #define FGGB_RST		0x08
< #define FGGB_VERSION		0x10
< #define FGGB_INTPENDING		0x40
< #define FGGB_INTMASK		0x44
< #define FGGB_PIPEMASK		0x48
< #define FGGB_HOSTINTERFACE	0xc000
< 
< G3D_CONFIG_STRUCT g3d_config={
< #ifdef CONFIG_PLAT_S3C64XX
< 	S3C_G3D_PA, 	// pool buffer addr
< 	0x90000, 	// pool_buffer_size
< 	1, 	// hardware_has_single_pipeline
< 	0, 	// is_dma_available
< #elif CONFIG_PLAT_S5PC1XX
<     S3C_G3D_PA,     // pool buffer addr
<     0x90000,    // pool_buffer_size
<     0,  // hardware_has_single_pipeline
< 	0,   // is_dma_available
< #elif CONFIG_CPU_S5P6442
< 	S3C_G3D_PA,     // pool buffer addr
< 	0x90000,    // pool_buffer_size
< 	1,  // hardware_has_single_pipeline
< 	0,   // is_dma_available
< #else
< #error "Hardware did not support 3D funtions."
< #endif
< 	0x57800000,     //dma buffer addr
< 	0x800000    //dma buffer size
< };
< 
< #define G3D_IOCTL_MAGIC		'S'
< #define WAIT_FOR_FLUSH		_IO(G3D_IOCTL_MAGIC, 100)
< #define GET_CONFIG 		_IO(G3D_IOCTL_MAGIC, 101)
< //#define START_DMA_BLOCK 	_IO(G3D_IOCTL_MAGIC, 102)
< 
< #define S3C_3D_MEM_ALLOC		_IOWR(G3D_IOCTL_MAGIC, 310, struct s3c_3d_mem_alloc)
< #define S3C_3D_MEM_FREE			_IOWR(G3D_IOCTL_MAGIC, 311, struct s3c_3d_mem_alloc)
< #define S3C_3D_SFR_LOCK			_IO(G3D_IOCTL_MAGIC, 312)
< #define S3C_3D_SFR_UNLOCK		_IO(G3D_IOCTL_MAGIC, 313)
< #define S3C_3D_MEM_ALLOC_SHARE		_IOWR(G3D_IOCTL_MAGIC, 314, struct s3c_3d_mem_alloc)
< #define S3C_3D_MEM_SHARE_FREE		_IOWR(G3D_IOCTL_MAGIC, 315, struct s3c_3d_mem_alloc)
< #define S3C_3D_CACHE_INVALID		_IOWR(G3D_IOCTL_MAGIC, 316, struct s3c_3d_mem_alloc)
< #define S3C_3D_CACHE_CLEAN			_IOWR(G3D_IOCTL_MAGIC, 317, struct s3c_3d_mem_alloc)
< #define S3C_3D_CACHE_CLEAN_INVALID			_IOWR(G3D_IOCTL_MAGIC, 318, struct s3c_3d_mem_alloc)
< 
< #define S3C_3D_POWER_INIT 			_IOWR('S', 321, struct s3c_3d_pm_status)
< #define S3C_3D_CRITICAL_SECTION  	_IOWR('S', 322, struct s3c_3d_pm_status)
< #define S3C_3D_POWER_STATUS 		_IOWR('S', 323, struct s3c_3d_pm_status)
< #define S3C_3D_MAP_FIMG_SFR_ADDR     	_IOWR(G3D_IOCTL_MAGIC, 324, struct s3c_3d_mem_alloc)
< #define S3C_3D_UNMAP_FIMG_SFR_ADDR  _IOWR(G3D_IOCTL_MAGIC, 325, struct s3c_3d_mem_alloc)
< 
< #define MEM_ALLOC		1
< #define MEM_ALLOC_SHARE		2
< #define GET_FIMG_ADDR 3
< 
< #define PFX 			"s3c_g3d"
< #define G3D_MINOR  		249
< 
< #define True			1
< #define False			0
< 
< static wait_queue_head_t waitq;
< static struct resource *s3c_g3d_mem;
< static void __iomem *s3c_g3d_base;
< static int s3c_g3d_irq;
< static struct clk *g3d_clock;
< 
< static DEFINE_MUTEX(mem_alloc_lock);
< static DEFINE_MUTEX(mem_free_lock);
< static DEFINE_MUTEX(mem_sfr_lock);
< 
< static DEFINE_MUTEX(mem_alloc_share_lock);
< static DEFINE_MUTEX(mem_share_free_lock);
< 
< static DEFINE_MUTEX(cache_clean_lock);
< static DEFINE_MUTEX(cache_invalid_lock);
< static DEFINE_MUTEX(cache_clean_invalid_lock);
< 
< static DEFINE_MUTEX(pm_power_init);
< static DEFINE_MUTEX(pm_critical_section_lock);
< static DEFINE_MUTEX(pm_status_lock);
< 
< void *dma_3d_done;
< 
< struct s3c_3d_mem_alloc {
< 	int		size;
< 	unsigned int 	vir_addr;
< 	unsigned int 	phy_addr;
< };
< 
< struct s3c_3d_pm_status
---
> static inline int g3d_flush(struct g3d_drvdata *data, unsigned int mask)
342,354c147
< 	unsigned int criticalSection;
< 	int powerStatus;
< 	int reserved;
< //	int memStatus;
< };
< 
< static int g_G3D_CriticalFlag = 0;
< static int g_G3D_SelfPowerOFF = 0;
< static int g_G3D_PowerInit=0;
< 
< static unsigned int mutex_lock_processID = 0;
< 
< static int flag = 0;
---
> 	int ret = 0;
356c149,150
< static unsigned int physical_address;
---
> 	if((g3d_read(data, G3D_FGGB_PIPESTAT_REG) & mask) == 0)
> 		return 0;
358c152,158
< int interrupt_already_recevied;
---
> 	/* Setup the interrupt */
> 	data->mask = mask;
> 	init_completion(&data->completion);
> 	g3d_write(data, 0, G3D_FGGB_PIPEMASK_REG);
> 	g3d_write(data, 0, G3D_FGGB_PIPETGTSTATE_REG);
> 	g3d_write(data, mask, G3D_FGGB_PIPEMASK_REG);
> 	g3d_write(data, 1, G3D_FGGB_INTMASK_REG);
360,383c160,164
< unsigned int s3c_g3d_base_physical;
< 
< void s3c_g3d_release_chunk(unsigned int phy_addr, int size);
< 
< ///////////// for check memory leak
< //*-------------------------------------------------------------------------*/
< typedef struct _memalloc_desc
< {
< 	int		size;
< 	unsigned int 	vir_addr;
< 	unsigned int 	phy_addr;
< 	int*    newid;
< 	struct _memalloc_desc*  next;
< 	struct _memalloc_desc*  prev;
< } Memalloc_desc;
< 
< void garbageCollect(int *newid);
< 
< static int g3d_pm_flag = 0;
< static void clk_g3d_enable(void)
< {
< 	if (g3d_pm_flag > 0) {
< 		g3d_pm_flag++;
< 		return;
---
> 	/* Check if the condition isn't already met */
> 	if((g3d_read(data, G3D_FGGB_PIPESTAT_REG) & mask) == 0) {
> 		/* Disable the interrupt */
> 		g3d_write(data, 0, G3D_FGGB_INTMASK_REG);
> 		return 0;
386,393c167,171
< 	clk_enable(g3d_clock);
< 	g3d_pm_flag++;
< }
< 
< static void clk_g3d_disable(void)
< {
< 	if (g3d_pm_flag <= 0) {
< 		return;
---
> 	if(!wait_for_completion_interruptible_timeout(&data->completion,
> 							G3D_TIMEOUT)) {
> 		ERR("Timeout while waiting for interrupt, resetting\n");
> 		g3d_soft_reset(data);
> 		ret = -EFAULT;
396,398c174,175
< 	g3d_pm_flag--;
< 	clk_disable(g3d_clock);
< }
---
> 	/* Disable the interrupt */
> 	g3d_write(data, 0, G3D_FGGB_INTMASK_REG);
400,426c177
< #ifdef USE_G3D_DOMAIN_GATING
< static void softReset_g3d(void)
< {
<     int i=0;
<     // device reset
<     __raw_writel(1,s3c_g3d_base+FGGB_RST);
<     for(i=0;i<1000;i++);
<     __raw_writel(0,s3c_g3d_base+FGGB_RST);
<     for(i=0;i<1000;i++);
< 
< }
< 
< void s3c_g3d_timer(void)
< {
< 	if (!g_G3D_PowerInit)
< 		return;
< 	if (g_G3D_CriticalFlag > 0)
< 	{/*turn on*/
< 		mod_timer(&g3d_pm_timer, jiffies + TIMER_INTERVAL);
< 		g_G3D_SelfPowerOFF=False;
< 		return;
< 	}
< 	/*turn off*/
< 	clk_g3d_disable();
< 	DOMAIN_POWER_OFF;
< 	g_G3D_SelfPowerOFF=True;
< 	//printk("[3D] Power off-timer wait\n");
---
> 	return ret;
428d178
< #endif /* USE_G3D_DOMAIN_GATING */
430c180
< irqreturn_t s3c_g3d_isr(int irq, void *dev_id)
---
> static inline void g3d_flush_caches(struct g3d_drvdata *data)
432,435c182,183
< 	__raw_writel(0, s3c_g3d_base + FGGB_INTPENDING);
< 
< 	interrupt_already_recevied = 1;
< 	wake_up_interruptible(&waitq);
---
> 	int timeout = 1000000000;
> 	g3d_write(data, G3D_FGGB_FLUSH_MSK, G3D_FGGB_CACHECTL_REG);
437c185,188
< 	return IRQ_HANDLED;
---
> 	do {
> 		if(!g3d_read(data, G3D_FGGB_CACHECTL_REG))
> 			break;
> 	} while (--timeout);
440c191
< unsigned int s3c_g3d_get_current_used_mem(void)
---
> static inline void g3d_invalidate_caches(struct g3d_drvdata *data)
442,454c193,194
< 	int loop_i;
< 	int iAvalable = 0;
< 	int iUsed = 0;
< 
< 	for(loop_i = 0; loop_i < G3D_CHUNK_NUM; loop_i++ ){
< 		if( g3d_bootm[loop_i].in_used == G3D_CHUCNK_AVALIABLE){
< 			iAvalable++;
< 		}
< 		else { /*G3D_CHUCNK_RESERVED Used Memory*/
< 			iUsed++;
< 		}
< 	}
< 	printk("used count %d\n", iUsed);
---
> 	int timeout = 1000000000;
> 	g3d_write(data, G3D_FGGB_INVAL_MSK, G3D_FGGB_CACHECTL_REG);
456c196,199
< 	return iUsed * G3D_CHUNK_SIZE / SZ_1M;
---
> 	do {
> 		if(!g3d_read(data, G3D_FGGB_CACHECTL_REG))
> 			break;
> 	} while (--timeout);
459,463c202,204
< void s3c_g3d_dma_finish(struct s3c2410_dma_chan *dma_ch, void *buf_id,
< 	int size, enum s3c2410_dma_buffresult result){
< //	printk("3d dma transfer completed.\n");
< 	complete(dma_3d_done);
< }
---
> /*
> 	State processing
> */
465c206
< int s3c_g3d_open(struct inode *inode, struct file *file)
---
> static irqreturn_t g3d_handle_irq(int irq, void *dev_id)
467,470c208,209
< 	int *newid;
< 
< 	newid = (int*)vmalloc(sizeof(int));
< 	file->private_data = newid;
---
> 	struct g3d_drvdata *data = (struct g3d_drvdata *)dev_id;
> 	uint32_t stat;
472c211,212
< 	g_G3D_SelfPowerOFF=True; //temp first turn on
---
> 	g3d_write(data, 0, G3D_FGGB_INTPENDING_REG);
> 	stat = g3d_read(data, G3D_FGGB_PIPESTAT_REG) & data->mask;
474,475c214,215
< 	/*3D power manager initialized*/
< 	g_G3D_PowerInit = True;
---
> 	if(!stat)
> 		complete(&data->completion);
477c217
< 	return 0;
---
> 	return IRQ_HANDLED;
480c220
< int s3c_g3d_release(struct inode *inode, struct file *file)
---
> static inline int ctx_has_lock(struct g3d_context *ctx)
482,486c222
< 	int *newid = file->private_data;
< 	if(mutex_lock_processID != 0 && mutex_lock_processID == (unsigned int)file->private_data) {
<         	mutex_unlock(&mem_sfr_lock);
< 	        printk("Abnormal close of pid # %d\n", task_pid_nr(current));
< 	}
---
> 	struct g3d_drvdata *data = ctx->data;
488,491c224
< 	garbageCollect(newid);
< 	vfree(newid);
< 
< 	return 0;
---
> 	return mutex_is_locked(&data->hw_lock) && (data->owner == ctx);
494,497c227,229
< static unsigned long long  genMemmapMask(u64 uirequestblock)
< {
< 	int i;
< 	unsigned long long uiMemMask = 0;
---
> /*
> 	Power management
> */
499c231
< 	for (i = 0 ; i < uirequestblock ; i++)
---
> static inline int g3d_do_power_up(struct g3d_drvdata *data)
501c233,237
< 		uiMemMask |= (0x1 << i);
---
> #ifdef CONFIG_S3C64XX_DOMAIN_GATING
> 	s3c_set_normal_cfg(S3C64XX_DOMAIN_G, S3C64XX_ACTIVE_MODE, S3C64XX_3D);
> 
> 	if (s3c_wait_blk_pwr_ready(S3C64XX_BLK_G)) {
> 		return -1;
502a239,241
> #endif
> 	clk_enable(data->clock);
> 	g3d_soft_reset(data);
504c243
< 	return uiMemMask;
---
> 	return 1;
507c246
< void printRemainChunk(void)
---
> static inline void g3d_do_power_down(struct g3d_drvdata *data)
509,515c248,252
< 	int loop_i, j = 0;
< 		for(loop_i = 0; loop_i < G3D_CHUNK_NUM; loop_i++ ) {
< 			if( g3d_bootm[loop_i].in_used == G3D_CHUCNK_AVALIABLE ) {
< 			j++;
< 			}
< 		}
< //	printk("Available Count %d\n", j);
---
> 	clk_disable(data->clock);
> #ifdef CONFIG_S3C64XX_DOMAIN_GATING
> 	s3c_set_normal_cfg(S3C64XX_DOMAIN_G, S3C64XX_LP_MODE, S3C64XX_3D);
> #endif
> 	data->owner = NULL;
518c255,257
< void low_memory_killer(unsigned int uiRequsetBlock, u64 uiMemMask,unsigned int id)
---
> #ifdef USE_G3D_DOMAIN_GATING
> /* Called with mutex locked */
> static inline int g3d_power_up(struct g3d_drvdata *data)
520,526c259
< 	alloc_info *s_info = alloc_info_head;
< 	alloc_info *k_info = NULL;
< 	unsigned int kill_id;
< 	int loop_i;
< 
< 	int chunk_start_num;
< 	int chunk_end_num;
---
> 	int ret;
528c261,262
< //	printk("low_memory_killer uiRequsetBlock=%d uiMemMask=0x%x\n",uiRequsetBlock, uiMemMask);
---
> 	if (data->state)
> 		return 0;
530,572c264,266
< 	if(!s_info)
< 	{
< 		printk("surfaceflinger's memory not found\n");
< 		return ;
< 	}
< 
< 	chunk_start_num = G3D_UI_CHUNK_NUM;
< 	chunk_end_num = G3D_CHUNK_NUM;
< 
< 	s_info=s_info->next;	// the first s_info is surfaceflinger
< #if 0
< 	while(s_info)
< 	{
< 		for(loop_i = chunk_start_num; loop_i < chunk_end_num - (uiRequsetBlock -1) ; loop_i++ ) {
< 
< 			if ((s_info->uiAllocedMemMap & (uiMemMask << loop_i)) == (uiMemMask << loop_i)){
< 				k_info=s_info;
< 				break;
< 			}
< 
< 		}
< 		if(k_info) break;
< 		s_info=s_info->next;
< 	}
< #else
<       k_info = s_info;
< 
< #endif
< 
< 	if(!k_info || k_info->file_desc_id==id)
< 	{
< #if 0	
< 		if(k_info==alloc_info_tail) printk("k_info==self\n");
< 		else printk("k_info==NULL\n");
< 		//printk("oldest 3D process's memory not found\n");
< #else
< 		if(!k_info) printk("k_info==NULL\n");
< #endif
< 		return ;
< 	}
< 
< 	kill_id = k_info->file_desc_id;
< //	printk("low momory killer : kill the oldest process(0x%x)\n",kill_id);
---
> 	INFO("Requesting power up.\n");
> 	if((ret = g3d_do_power_up(data)) > 0)
> 		data->state = 1;
574,583c268
< 	kill_pid(k_info->pId , SIGTERM, 1);
< 
< 	for(loop_i = G3D_UI_CHUNK_NUM ; loop_i < G3D_CHUNK_NUM; loop_i++ ){
< 		if((g3d_bootm[loop_i].file_desc_id) == (unsigned int)kill_id){
< 			if (g3d_bootm[loop_i].in_used == G3D_CHUCNK_RESERVED){
< 		        		s3c_g3d_release_chunk(g3d_bootm[loop_i].phy_addr, g3d_bootm[loop_i].size);
< 			}
< 			g3d_bootm[loop_i].file_desc_id = 0;
< 	  	}
<   	}
---
> 	return ret;
586c271,272
< unsigned long s3c_g3d_available_chunk_size(unsigned int request_size, unsigned int id)
---
> /* Called with mutex locked */
> static inline void g3d_power_down(struct g3d_drvdata *data)
588,636c274,275
< 	unsigned int loop_i, loop_j;
< 
< 	unsigned int uiRequsetBlock = (int)(request_size / G3D_CHUNK_SIZE);
< 	unsigned long long uiMemMask = genMemmapMask(uiRequsetBlock);
< 
< 	int chunk_start_num;
< 	int chunk_end_num;
< 	int enable_lmk;
< 
< 	if (request_size % G3D_CHUNK_SIZE > 0)
< 		uiRequsetBlock += 1;
< 
< 
< 	if(!alloc_info_head)
< 	{
< 		enable_lmk = 0;
< 		chunk_start_num = 0;
< 		chunk_end_num = G3D_UI_CHUNK_NUM;
< 	}
< 	else if(alloc_info_head->file_desc_id==id) {
< 		enable_lmk = 0;
< 		chunk_start_num = 0;
< 		chunk_end_num = G3D_UI_CHUNK_NUM;
< 	}
< 	else{
< 		enable_lmk = 1;
< 		chunk_start_num = G3D_UI_CHUNK_NUM;
< 		chunk_end_num = G3D_CHUNK_NUM;
< 	}
< 
< 	for(loop_j = 0; loop_j < 3; loop_j++ ) {
< 		//for(loop_j = 0; loop_j < 10; loop_j++ ) {
< 		for(loop_i = chunk_start_num; loop_i < chunk_end_num - (uiRequsetBlock -1) ; loop_i++ ) {
< 
< 			if ((g_uiFreeMemMap & (uiMemMask << loop_i)) == (uiMemMask << loop_i))
< 				return G3D_CHUNK_SIZE * uiRequsetBlock;
< 		}
< 
< 	//	if(enable_lmk && (loop_j == 0)) low_memory_killer(uiRequsetBlock,uiMemMask,id);
< 	    if(loop_j <= 1){
< 		if(enable_lmk)  low_memory_killer(uiRequsetBlock,uiMemMask,id);
< 
< 		mutex_unlock(&mem_alloc_lock);
< 		//printk("wait 0.%d sec to get releaing memory\n", loop_j);
< 		msleep(1);
< 		//msleep(100);	
< 		mutex_lock(&mem_alloc_lock);
< 	    }
< 	}
---
> 	if(!data->state)
> 		return;
638c277
< 	printk("%s cannot find adequate memory!\n", enable_lmk ? "3D apps":"Surfaceflinger");
---
> 	INFO("Requesting power down.\n");
640c279,282
< 	return 0;
---
> 	g3d_flush(data, G3D_FGGB_PIPESTAT_MSK);
> 	g3d_flush_caches(data);
> 	g3d_do_power_down(data);
> 	data->state = 0;
643c285,286
< int check_memStatus(unsigned int id)
---
> /* Called with mutex locked */
> static enum hrtimer_restart g3d_idle_func(struct hrtimer *t)
645c288
< 	alloc_info *s_info = alloc_info_head;
---
> 	struct g3d_drvdata *data = container_of(t, struct g3d_drvdata, timer);
647,651c290
< 	while(s_info!=NULL)
< 	{
< 		if(s_info->file_desc_id == id) return 0;
< 		s_info = s_info->next;
< 	}
---
> 	g3d_power_down(data);
653c292
< 	return 1;
---
> 	return HRTIMER_NORESTART;
655,656c294,298
< 
< void register_alloc_info(int index,u64 uiAllocedMemMap )
---
> #endif
> /*
>  * File operations
>  */
> static int s3c_g3d_unlock(struct g3d_context *ctx)
658,659c300,301
< 	unsigned int id = g3d_bootm[index].file_desc_id;
< 	alloc_info *s_info = alloc_info_head;
---
> 	struct g3d_drvdata *data = ctx->data;
> 	int ret = 0;
661,687c303
< //	printk("<register_alloc_info index=%d id=0x%x AllocedMemMap=0x%x>\n",index,id,uiAllocedMemMap);
< 	while(s_info!=NULL)
< 	{
< 		if(s_info->file_desc_id == id) break;
< 		s_info = s_info->next;
< 	}
< 
< 	if(s_info)
< 	{
< 		if(s_info->uiAllocedMemMap & uiAllocedMemMap)
< 				printk("err uiAllocedMemMap\n");
< 		else s_info->uiAllocedMemMap|=uiAllocedMemMap;
< 	}
< 	else
< 	{
< 		s_info = vmalloc(sizeof(alloc_info));
< 		s_info->file_desc_id 	= id;
< 		s_info->pId				= task_pid(current);
< 		
< 		s_info->next 			= NULL;
< 		s_info->uiAllocedMemMap	= uiAllocedMemMap;
< 
< 		if(alloc_info_tail)
< 			alloc_info_tail->next = s_info;
< 		else
< 			alloc_info_head = s_info;
< 		alloc_info_tail = s_info;
---
> 	mutex_lock(&data->lock);
688a305,308
> 	if (unlikely(!ctx_has_lock(ctx))) {
> 		dev_err(data->dev, "called S3C_G3D_UNLOCK without holding the hardware lock\n");
> 		ret = -EPERM;
> 		goto exit;
689a310,316
> 
> #ifdef USE_G3D_DOMAIN_GATING
> 	hrtimer_start(&data->timer, ktime_set(G3D_IDLE_TIME_SECS, 0), HRTIMER_MODE_REL);
> #endif /* USE_G3D_DOMAIN_GATING */
> 
> 	mutex_unlock(&data->hw_lock);
> 	dev_dbg(data->dev, "hardware lock released by %p\n", ctx);
691,693c318,319
< #ifdef DEBUG_S3C_G3D
< 	g3d_alloc_info_dump();
< #endif
---
> exit:
> 	mutex_unlock(&data->lock);
694a321
> 	return ret;
697c324
< unsigned long s3c_g3d_reserve_chunk(struct file* filp, unsigned int size)
---
> static int s3c_g3d_lock(struct g3d_context *ctx)
699,708c326,327
< 	unsigned int loop_i, loop_j, loop_k;
< 
< 	unsigned int uiRequsetBlock = (int)(size / G3D_CHUNK_SIZE);
< 	unsigned long long uiMemMask = genMemmapMask(uiRequsetBlock);
< 
< 	int chunk_start_num;
< 	int chunk_end_num;
< 	int enable_lmk = 0;
< 
< 	unsigned int id = (unsigned int)filp->private_data;
---
> 	struct g3d_drvdata *data = ctx->data;
> 	int ret = 0;
710,731c329
< 	if (size % G3D_CHUNK_SIZE > 0)
< 		printk("s3c_g3d_reserve_chunk : wrong estimated reserve memory\n");
< 
< 	if(!alloc_info_head)
< 	{
< 		chunk_start_num = 0;
< 		chunk_end_num = G3D_UI_CHUNK_NUM;
< 	}
< 	else if(alloc_info_head->file_desc_id==id) {
< 		chunk_start_num = 0;
< 		chunk_end_num = G3D_UI_CHUNK_NUM;
< 	}
< 	else{
< 		chunk_start_num = G3D_UI_CHUNK_NUM;
< 		chunk_end_num = G3D_CHUNK_NUM;
< 		enable_lmk = 1;
< 	}
< 
< 	if(enable_lmk)  low_memory_killer(uiRequsetBlock,uiMemMask,id);
< 	
< //for(loop_k=0; loop_k<2 ; loop_k++){
<  	for(loop_i = chunk_start_num; loop_i < chunk_end_num - (uiRequsetBlock -1); loop_i++ ) {
---
> 	mutex_lock(&data->hw_lock);
733,739c331
< 		if ((g_uiFreeMemMap & (uiMemMask << loop_i)) == (uiMemMask << loop_i)) // check free memory at memory map
< 		{
< 			for(loop_j = loop_i; loop_j < loop_i + uiRequsetBlock ; loop_j++ )
< 			{
< 				g3d_bootm[loop_j].in_used = G3D_CHUCNK_RESERVED;
< 				g3d_bootm[loop_j].file_desc_id = (int)filp->private_data;
< 		 	}
---
> 	dev_dbg(data->dev, "hardware lock acquired by %p\n", ctx);
741,742c333
< 			g_uiFreeMemMap &= ~(uiMemMask << loop_i); // remove free chunk block at memory map
< 			register_alloc_info(loop_i,uiMemMask << loop_i);
---
> 	mutex_lock(&data->lock);
744,745c335,341
< 			printRemainChunk();
< 			return g3d_bootm[loop_i].phy_addr;
---
> #ifdef USE_G3D_DOMAIN_GATING
> 	if(!hrtimer_cancel(&data->timer)) {
> 		ret = g3d_power_up(data);
> 		if (ret < 0) {
> 			dev_err(data->dev, "Timeout while waiting for G3D power up\n");
> 			mutex_unlock(&data->hw_lock);
> 			goto exit;
747a344
> #endif /* USE_G3D_DOMAIN_GATING */
749c346,349
< //if(enable_lmk && (loop_k == 0))  low_memory_killer(uiRequsetBlock,uiMemMask,id);
---
> 	if (likely(data->owner == ctx)) {
> 		mutex_unlock(&data->lock);
> 		return 0;
> 	}
751c351
< //}
---
> 	ret = 1;
753c353,356
< 	printk("s3c_g3d_reserve_chunk failed : Cannot find adequate memory!\n");
---
> 	if (data->owner) {
> 		g3d_flush(data, G3D_FGGB_PIPESTAT_MSK);
> 		ret = 2;
> 	}
755,756c358
< 	return 0;
< }
---
> 	data->owner = ctx;
758,807c360,361
< void unregister_alloc_info(int index, u64 uiAllocedMemMap)
< {
< 	unsigned int id = g3d_bootm[index].file_desc_id;
< 	alloc_info *s_info = alloc_info_head;
< 	alloc_info *pre_info = NULL;
< 
< //	printk("<unregister_alloc_info index=%d id=0x%x>\n",index,id);
< 
< 	while(s_info!=NULL)
< 	{
< 		if(s_info->file_desc_id == id) break;
< 		pre_info = s_info;
< 		s_info = s_info->next;
< 	}
< 
< 	if(s_info)
< 	{
< 		if(s_info->uiAllocedMemMap==uiAllocedMemMap)
< 		{
< 			if(pre_info)
< 			{
< 				pre_info->next = s_info->next;
< 				if(alloc_info_tail==s_info) alloc_info_tail = pre_info;
< 			}
< 			else	// case : surfaceflinger is killed
< 			{
< //				printk("warnning : surfaceflinger is killed\n");
< 				alloc_info_head = s_info->next;
< 				if(alloc_info_tail==s_info) alloc_info_tail = NULL;
< 			}
< 
< 			vfree(s_info);
< 		}
< 		else
< 		{
< 			if(s_info->uiAllocedMemMap && uiAllocedMemMap !=uiAllocedMemMap){
< 				printk("unregister_alloc_info err \n");
< 				return;
< 			}
< 			s_info->uiAllocedMemMap &= ~uiAllocedMemMap;
< 		}
< 	}
< 	else
< 	{
< 		printk("unregister_alloc_info err \n");
< 		return;
< 	}
< #ifdef DEBUG_S3C_G3D
< 	g3d_alloc_info_dump();
< #endif
---
> exit:
> 	mutex_unlock(&data->lock);
808a363
> 	return ret;
811c366
< void s3c_g3d_release_chunk(unsigned int phy_addr, int size)
---
> static int s3c_g3d_flush(struct g3d_context *ctx, u32 mask)
813,814c368,369
< 	unsigned int loop_i, loop_j;
< 	struct mm_struct *mm = current->mm;
---
> 	struct g3d_drvdata *data = ctx->data;
> 	int ret = 0;
816,817c371
< 	unsigned int uiRequsetBlock = (int)(size / G3D_CHUNK_SIZE);
< 	unsigned long long uiMemMask = genMemmapMask(uiRequsetBlock);	
---
> 	mutex_lock(&data->lock);
819,839c373,376
< 	for(loop_i = 0; loop_i < G3D_CHUNK_NUM - (uiRequsetBlock - 1); loop_i++ ) {
< 		if( g3d_bootm[loop_i].phy_addr == phy_addr ) {
< 
< 			if ((g_uiFreeMemMap & (uiMemMask << loop_i)) != 0) // check free memory at memory map
< 			{
< 				printk("s3c_g3d_release_chunk : memory map is crashed");
< 				break;
< 			}
< 
< 			do_munmap(mm, g3d_bootm[loop_i].vir_addr, size);
< 			g_uiFreeMemMap |= (uiMemMask << loop_i); // add free chunk block at memory map
< 			unregister_alloc_info(loop_i,uiMemMask << loop_i);
< 
< 			for(loop_j = loop_i; loop_j < loop_i + uiRequsetBlock ; loop_j++ )
< 			{
< 				g3d_bootm[loop_j].in_used = G3D_CHUCNK_AVALIABLE;
< 				g3d_bootm[loop_j].file_desc_id = 0;
< 			}
< 
< 			break;
< 		}
---
> 	if (unlikely(!ctx_has_lock(ctx))) {
> 		dev_err(data->dev, "called S3C_G3D_FLUSH without holding the hardware lock\n");
> 		ret = -EPERM;
> 		goto exit;
842,843c379,382
< 	if(loop_i >= G3D_CHUNK_NUM)
< 		printk("s3c_g3d_release_chunk failed : Cannot find the phys_addr : 0x%p\n", (void*)phy_addr);
---
> 	ret = g3d_flush(data, mask & G3D_FGGB_PIPESTAT_MSK);
> 
> exit:
> 	mutex_unlock(&data->lock);
845c384
< 	printRemainChunk();
---
> 	return ret;
846a386,388
> /*
> 	File operations
> */
848c390,391
< static int s3c_g3d_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
---
> static int s3c_g3d_ioctl(struct inode *inode, struct file *file,
> 				unsigned int cmd, unsigned long arg)
850,1151c393,394
< 	u32 val;
< 	DECLARE_COMPLETION_ONSTACK(complete);
< 
< 	struct mm_struct *mm = current->mm;
< 	struct s3c_3d_mem_alloc param;
< 	struct s3c_3d_pm_status param_pm;
< 
< 	unsigned int timer;
< 
< 	switch (cmd) {
< 	case WAIT_FOR_FLUSH:
< 		//if fifo has already been flushed, return;
< 		val = __raw_readl(s3c_g3d_base+FGGB_PIPESTATE);
< 		//printk("read pipestate = 0x%x\n",val);
< 		if((val & arg) ==0) break;
< 
< 		// enable interrupt
< 		interrupt_already_recevied = 0;
< 		__raw_writel(0x0001171f,s3c_g3d_base+FGGB_PIPEMASK);
< 		__raw_writel(1,s3c_g3d_base+FGGB_INTMASK);
< 
< 		//printk("wait for flush (arg=0x%lx)\n",arg);
< 
< 		timer = 1000000;
< 
< 		while(timer) {
< 			wait_event_interruptible_timeout(waitq, (interrupt_already_recevied>0), 1*HZ);
< 
< 			__raw_writel(0,s3c_g3d_base+FGGB_INTMASK);
< 			interrupt_already_recevied = 0;
< 			//if(interrupt_already_recevied==0)interruptible_sleep_on(&waitq);
< 			val = __raw_readl(s3c_g3d_base+FGGB_PIPESTATE);
< 			//printk("in while read pipestate = 0x%x\n",val);
< 			if(val & arg){
< 			} else{
< 				break;
< 			}
< 			__raw_writel(1,s3c_g3d_base+FGGB_INTMASK);
< 			timer --;
< 		}
< 		break;
< 
< 	case GET_CONFIG:
< 		if (copy_to_user((void *)arg,&g3d_config,sizeof(G3D_CONFIG_STRUCT))) {
< 			printk("G3D: copy_to_user failed to get g3d_config\n");
< 			return -EFAULT;
< 		}
< 		break;
< 
< #if 0
< 	case START_DMA_BLOCK:
< 		if (copy_from_user(&dma_block,(void *)arg,sizeof(DMA_BLOCK_STRUCT))) {
< 			printk("G3D: copy_to_user failed to get dma_block\n");
< 			return -EFAULT;
< 		}
< 
< 		if (dma_block.offset%4!=0) {
< 			printk("G3D: dma offset is not aligned by word\n");
< 			return -EINVAL;
< 		}
< 		if (dma_block.size%4!=0) {
< 			printk("G3D: dma size is not aligned by word\n");
< 			return -EINVAL;
< 		}
< 		if (dma_block.offset+dma_block.size >g3d_config.dma_buffer_size) {
< 			printk("G3D: offset+size exceeds dam buffer\n");
< 			return -EINVAL;
< 		}
< 
< 		dma_info.src = g3d_config.dma_buffer_addr+dma_block.offset;
< 		dma_info.len = dma_block.size;
< 		dma_info.dst = s3c_g3d_base_physical+FGGB_HOSTINTERFACE;
< 
< 		DEBUG(" dma src=0x%x\n", dma_info.src);
< 		DEBUG(" dma len =%u\n", dma_info.len);
< 		DEBUG(" dma dst = 0x%x\n", dma_info.dst);
< 
< 		dma_3d_done = &complete;
< 
< 		if (s3c2410_dma_request(DMACH_3D_M2M, &s3c6410_3d_dma_client, NULL)) {
< 			printk(KERN_WARNING "Unable to get DMA channel(DMACH_3D_M2M).\n");
< 			return -EFAULT;
< 		}
< 
< 		s3c2410_dma_set_buffdone_fn(DMACH_3D_M2M, s3c_g3d_dma_finish);
< 		s3c2410_dma_devconfig(DMACH_3D_M2M, S3C_DMA_MEM2MEM, 1, (u_long) dma_info.src);
< 		s3c2410_dma_config(DMACH_3D_M2M, 4, 4);
< 		s3c2410_dma_setflags(DMACH_3D_M2M, S3C2410_DMAF_AUTOSTART);
< 
< 		//consistent_sync((void *) dma_info.dst, dma_info.len, DMA_FROM_DEVICE);
< 	//	s3c2410_dma_enqueue(DMACH_3D_M2M, NULL, (dma_addr_t) virt_to_dma(NULL, dma_info.dst), dma_info.len);
< 		s3c2410_dma_enqueue(DMACH_3D_M2M, NULL, (dma_addr_t) dma_info.dst, dma_info.len);
< 
< 	//	printk("wait for end of dma operation\n");
< 		wait_for_completion(&complete);
< 	//	printk("dma operation is performed\n");
< 
< 		s3c2410_dma_free(DMACH_3D_M2M, &s3c6410_3d_dma_client);
< 
< 		break;
< #endif
< 
< 
< 
< 
< 	case S3C_3D_MAP_FIMG_SFR_ADDR:
< 		mutex_lock(&mem_alloc_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 
< 		flag = GET_FIMG_ADDR;
< 		param.vir_addr = do_mmap(file, 0, param.size, PROT_READ|PROT_WRITE, MAP_SHARED, param.phy_addr);
< 		flag = 0;
< 	
< 		
< 		if(param.vir_addr == -EINVAL) {
< 			printk("S3C_3D_MEM_ALLOC_SHARE FAILED\n");
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 
< 		if(copy_to_user((struct s3c_3d_mem_alloc *)arg, &param, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 		mutex_unlock(&mem_alloc_lock);
< 		
< 		break;
< 
< 
< 
< 	case S3C_3D_UNMAP_FIMG_SFR_ADDR:
< 		
< 		mutex_lock(&mem_alloc_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 		do_munmap(mm, param.vir_addr, param.size);
< 		mutex_unlock(&mem_alloc_lock);
< 		
< 		break;
< 
< 
< 
< 
< 	case S3C_3D_MEM_ALLOC:
< 		mutex_lock(&mem_alloc_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 		flag = MEM_ALLOC;
< 
< 		param.size = s3c_g3d_available_chunk_size(param.size,(unsigned int)file->private_data);
< 
< 		if (param.size == 0){
< 			//printk("S3C_3D_MEM_ALLOC FAILED because there is no block memory bigger than you request\n");
< 			flag = 0;
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 		param.vir_addr = do_mmap(file, 0, param.size, PROT_READ|PROT_WRITE, MAP_SHARED, 0);
< 		DEBUG("param.vir_addr = %08x\n", param.vir_addr);
< 
< 		if(param.vir_addr == -EINVAL) {
< 			printk("S3C_3D_MEM_ALLOC FAILED\n");
< 			flag = 0;
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 		param.phy_addr = physical_address;
< 
<        // printk("alloc %d\n", param.size);
< 		DEBUG("KERNEL MALLOC : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X\n", param.phy_addr, param.size, param.vir_addr);
< 
< 		if(copy_to_user((struct s3c_3d_mem_alloc *)arg, &param, sizeof(struct s3c_3d_mem_alloc))){
< 			flag = 0;
< 			mutex_unlock(&mem_alloc_lock);
< 			return -EFAULT;
< 		}
< 
< 		flag = 0;
< 
< //		printk("\n\n====Success the malloc from kernel=====\n");
< 		mutex_unlock(&mem_alloc_lock);
< 
< 		break;
< 
< 	case S3C_3D_MEM_FREE:
< 		mutex_lock(&mem_free_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_free_lock);
< 			return -EFAULT;
< 		}
< 
< 		DEBUG("KERNEL FREE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X\n", param.phy_addr, param.size, param.vir_addr);
< 
< 		/*
< 		if (do_munmap(mm, param.vir_addr, param.size) < 0) {
< 			printk("do_munmap() failed !!\n");
< 			mutex_unlock(&mem_free_lock);
< 			return -EINVAL;
< 		}
< 		*/
< 
< 		s3c_g3d_release_chunk(param.phy_addr, param.size);
< 		//printk("KERNEL : virt_addr = 0x%X\n", virt_addr);
< 		//printk("free %d\n", param.size);
< 
< 
< 		param.size = 0;
< 		DEBUG("do_munmap() succeed !!\n");
< 
< 		if(copy_to_user((struct s3c_3d_mem_alloc *)arg, &param, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_free_lock);
< 			return -EFAULT;
< 		}
< 
< 		mutex_unlock(&mem_free_lock);
< 
< 		break;
< 
< 	case S3C_3D_SFR_LOCK:
< 		mutex_lock(&mem_sfr_lock);
< 		mutex_lock_processID = (unsigned int)file->private_data;
< 		DEBUG("s3c_g3d_ioctl() : You got a muxtex lock !!\n");
< 		break;
< 
< 	case S3C_3D_SFR_UNLOCK:
< 		mutex_lock_processID = 0;
< 		mutex_unlock(&mem_sfr_lock);
< 		DEBUG("s3c_g3d_ioctl() : The muxtex unlock called !!\n");
< 		break;
< 
< 	case S3C_3D_MEM_ALLOC_SHARE:
< 		mutex_lock(&mem_alloc_share_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_alloc_share_lock);
< 			return -EFAULT;
< 		}
< 		flag = MEM_ALLOC_SHARE;
< 
< 		physical_address = param.phy_addr;
< 
< 		DEBUG("param.phy_addr = %08x\n", physical_address);
< 
< 		param.vir_addr = do_mmap(file, 0, param.size, PROT_READ|PROT_WRITE, MAP_SHARED, 0);
< 		DEBUG("param.vir_addr = %08x\n", param.vir_addr);
< 
< 		if(param.vir_addr == -EINVAL) {
< 			printk("S3C_3D_MEM_ALLOC_SHARE FAILED\n");
< 			flag = 0;
< 			mutex_unlock(&mem_alloc_share_lock);
< 			return -EFAULT;
< 		}
< 
< 		DEBUG("MALLOC_SHARE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X\n", param.phy_addr, param.size, param.vir_addr);
< 
< 		if(copy_to_user((struct s3c_3d_mem_alloc *)arg, &param, sizeof(struct s3c_3d_mem_alloc))){
< 			flag = 0;
< 			mutex_unlock(&mem_alloc_share_lock);
< 			return -EFAULT;
< 		}
< 
< 		flag = 0;
< 
< 		mutex_unlock(&mem_alloc_share_lock);
< 
< 		break;
< 
< 	case S3C_3D_MEM_SHARE_FREE:
< 		mutex_lock(&mem_share_free_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_share_free_lock);
< 			return -EFAULT;
< 		}
< 
< 		DEBUG("MEM_SHARE_FREE : param.phy_addr = 0x%X \t size = %d \t param.vir_addr = 0x%X\n", param.phy_addr, param.size, param.vir_addr);
< 
< 		if (do_munmap(mm, param.vir_addr, param.size) < 0) {
< 			printk("do_munmap() failed - MEM_SHARE_FREE!!\n");
< 			mutex_unlock(&mem_share_free_lock);
< 			return -EINVAL;
< 		}
< 
< 		param.vir_addr = 0;
< 		DEBUG("do_munmap() succeed !! - MEM_SHARE_FREE\n");
< 
< 		if(copy_to_user((struct s3c_3d_mem_alloc *)arg, &param, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&mem_share_free_lock);
< 			return -EFAULT;
< 		}
< 
< 		mutex_unlock(&mem_share_free_lock);
---
> 	struct g3d_context *ctx = file->private_data;
> 	int ret = 0;
1152a396,399
> 	switch(cmd) {
> 	/* Prepare and lock the hardware */
> 	case S3C_G3D_LOCK:
> 		ret = s3c_g3d_lock(ctx);
1155,1174c402,404
< 	case S3C_3D_CACHE_INVALID:
< 		mutex_lock(&cache_invalid_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			printk("ERR: Invalid Cache Error\n");
< 			mutex_unlock(&cache_invalid_lock);
< 			return -EFAULT;
< 		}
< 		dmac_inv_range((const void *) param.vir_addr,(const void *)(param.vir_addr + param.size));
< 		mutex_unlock(&cache_invalid_lock);
< 		break;
< 
< 	case S3C_3D_CACHE_CLEAN:
< 		mutex_lock(&cache_clean_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			printk("ERR: Invalid Cache Error\n");
< 			mutex_unlock(&cache_clean_lock);
< 			return -EFAULT;
< 		}
< 		dmac_clean_range((const void *) param.vir_addr,(const void *)(param.vir_addr + param.size));
< 		mutex_unlock(&cache_clean_lock);
---
> 	/* Unlock the hardware and start idle timer */
> 	case S3C_G3D_UNLOCK:
> 		ret = s3c_g3d_unlock(ctx);
1177,1256c407,409
< 	case S3C_3D_CACHE_CLEAN_INVALID:
< 		mutex_lock(&cache_clean_invalid_lock);
< 		if(copy_from_user(&param, (struct s3c_3d_mem_alloc *)arg, sizeof(struct s3c_3d_mem_alloc))){
< 			mutex_unlock(&cache_clean_invalid_lock);
< 			printk("ERR: Invalid Cache Error\n");
< 			return -EFAULT;
< 		}
< 		dmac_flush_range((const void *) param.vir_addr,(const void *)(param.vir_addr + param.size));
< 		mutex_unlock(&cache_clean_invalid_lock);
< 		break;
< 
< 	case S3C_3D_POWER_INIT:
< 		if(copy_from_user(&param_pm, (struct s3c_3d_pm_status *)arg, sizeof(struct s3c_3d_pm_status))){
< 			printk("ERR: Invalid Cache Error\n");
< 			return -EFAULT;
< 		}
< 		break;
< 
< 	case S3C_3D_CRITICAL_SECTION:
< #ifdef USE_G3D_DOMAIN_GATING
< 		mutex_lock(&pm_critical_section_lock);
< 		if(copy_from_user(&param_pm, (struct s3c_3d_pm_status *)arg, sizeof(struct s3c_3d_pm_status))){
< 			printk("ERR: Invalid Cache Error\n");
< 			mutex_unlock(&pm_critical_section_lock);
< 			return -EFAULT;
< 		}
< 
< //		param_pm.memStatus = check_memStatus((unsigned int)file->private_data);
< 
< 		if(param_pm.criticalSection) g_G3D_CriticalFlag++;
< 		else g_G3D_CriticalFlag--;
< 
< 		if(g_G3D_CriticalFlag==0)
< 		{/*kick power off*/
< 			/*power off*/
< 			/*kick timer*/
< 			mod_timer(&g3d_pm_timer, jiffies + TIMER_INTERVAL);
< 		}
< 		else if(g_G3D_CriticalFlag>0)
< 		{/*kick power on*/
< 			if(IS_DOMAIN_POWER_OFF)
< 			{/*if powered off*/
< 				if(g_G3D_SelfPowerOFF)
< 				{/*powered off by 3D PM or by Resume*/
< 					/*power on*/
< 					DOMAIN_POWER_ON;
< 					clk_g3d_enable();
< 					/*Need here??*/
< 					softReset_g3d();
< 					// printk("[3D] Power on\n");
< 				}
< 				else
< 				{
< 					/*powered off by the system :: error*/
< 					printk("Error on the system :: app tries to work during sleep\n");
< 					mutex_unlock(&pm_critical_section_lock);
< 					return -EFAULT;
< 				}
< 			}
< 			else
< 			{
<                                 /*already powered on : nothing to do*/
< 				//g_G3D_SelfPowerOFF=0;
< 			}
< 		}
< 		else if(g_G3D_CriticalFlag < 0)
< 		{
< 			printk("Error on the system :: g_G3D_CriticalFlag < 0\n");
< 		}
< //		printk("S3C_3D_CRITICAL_SECTION: param_pm.criticalSection=%d\n",param_pm.criticalSection);
< 
< 		if (copy_to_user((void *)arg,&param_pm,sizeof(struct s3c_3d_pm_status)))
< 		{
< 			printk("G3D: copy_to_user failed to get s3c_3d_pm_status\n");
< 
< 			mutex_unlock(&pm_critical_section_lock);
< 			return -EFAULT;
< 		}
< 		mutex_unlock(&pm_critical_section_lock);
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	/* Wait for the hardware to finish its work */
> 	case S3C_G3D_FLUSH:
> 		ret = s3c_g3d_flush(ctx, arg & G3D_FGGB_PIPESTAT_MSK);
1260,1261c413
< 		DEBUG("s3c_g3d_ioctl() : default !!\n");
< 		return -EINVAL;
---
> 		ret = -EINVAL;
1264c416
< 	return 0;
---
> 	return ret;
1267c419
< int s3c_g3d_mmap(struct file* filp, struct vm_area_struct *vma)
---
> static int s3c_g3d_open(struct inode *inode, struct file *file)
1269c421
< 	unsigned long pageFrameNo, size, phys_addr;
---
> 	struct g3d_context *ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
1271,1272c423,425
< 	size = vma->vm_end - vma->vm_start;
< 	
---
> 	ctx->data = drvdata;
> 	file->private_data = ctx;
> 	DBG("device opened\n");
1274,1282c427,428
< 	switch (flag) {
< 	case MEM_ALLOC :
< 		
< 		phys_addr = s3c_g3d_reserve_chunk(filp, size);
< 
< 		if (phys_addr == 0) {
< 			printk("There is no reserved memory for G3D!\n");
< 			return -EINVAL;
< 		}
---
> 	return 0;
> }
1284,1286c430,435
< //		DEBUG("MMAP_ALLOC : virt addr = 0x%p, size = %d\n", virt_addr, size);
< //		printk("MMAP_ALLOC : virt addr = 0x%p, phys addr = 0x%p, size = %d\n", (void*)virt_addr, (void*)phys_addr, (int)(size));
< 		physical_address = (unsigned int)phys_addr;
---
> static int s3c_g3d_release(struct inode *inode, struct file *file)
> {
> 	struct g3d_context *ctx = file->private_data;
> 	struct g3d_drvdata *data = ctx->data;
> 	unsigned long flags;
> 	int unlock = 0;
1288,1289c437,441
< 		pageFrameNo = __phys_to_pfn(phys_addr);
< 		break;
---
> 	/* Do this atomically */
> 	local_irq_save(flags);
> 	if(mutex_is_locked(&data->lock) && data->owner == ctx)
> 		unlock = 1;
> 	local_irq_restore(flags);
1291,1292c443,445
< 	case MEM_ALLOC_SHARE :
< //		DEBUG("MMAP_KMALLOC_SHARE : phys addr = 0x%p\n", physical_address);
---
> 	/* Unlock if we have the lock */
> 	if(unlock)
> 		s3c_g3d_ioctl(inode, file, S3C_G3D_UNLOCK, 0);
1294,1298c447,448
< 		// page frame number of the address for the physical_address to be shared.
< 		pageFrameNo = __phys_to_pfn(physical_address);
< 		//DEBUG("MMAP_KMALLOC_SHARE: PFN = 0x%x\n", pageFrameNo);
< //		DEBUG("MMAP_KMALLOC_SHARE : vma->end = 0x%p, vma->start = 0x%p, size = %d\n", vma->vm_end, vma->vm_start, size);
< 		break;
---
> 	kfree(ctx);
> 	DBG("device released\n");
1300,1305c450,451
< 	case GET_FIMG_ADDR:
< 	
< 			
< 			// page frame number of the address for a source G3D_SFR_SIZE to be stored at.
< 			pageFrameNo = __phys_to_pfn(S3C_G3D_PA);	
< 			break;
---
> 	return 0;
> }
1306a453,456
> int s3c_g3d_mmap(struct file* file, struct vm_area_struct *vma)
> {
> 	unsigned long pfn;
> 	size_t size = vma->vm_end - vma->vm_start;
1308,1309c458
< 	default :
< 		printk("here\n");
---
> 	pfn = __phys_to_pfn(G3D_SFR_BASE);
1311,1319c460,462
< 		// page frame number of the address for a source G2D_SFR_SIZE to be stored at.
< 		pageFrameNo = __phys_to_pfn(S3C_G3D_PA);
< //		DEBUG("MMAP : vma->end = 0x%p, vma->start = 0x%p, size = %d\n", vma->vm_end, vma->vm_start, size);
< 
< 		if(size > S3C6410_SZ_G3D) {
< 			printk("The size of G3D_SFR_SIZE mapping is too big!\n");
< 			return -EINVAL;
< 		}
< 		break;
---
> 	if(size > G3D_SFR_SIZE) {
> 		ERR("mmap size bigger than G3D SFR block\n");
> 		return -EINVAL;
1322c465
< //	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
---
> 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
1325c468
< 		printk("s3c_g3d_mmap() : Writable G3D_SFR_SIZE mapping must be shared !\n");
---
> 		ERR("mmap of G3D SFR block must be shared\n");
1329,1330c472,473
< 	if (remap_pfn_range(vma, vma->vm_start, pageFrameNo, size, vma->vm_page_prot)) {
< 		printk("s3c_g3d_mmap() : remap_pfn_range() failed !\n");
---
> 	if (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) {
> 		ERR("remap_pfn range failed\n");
1334,1342c477
< 	return 0;
< }
< 
< void garbageCollect(int* newid)
< {
< 	int loop_i;
< 
< //      printk("====Garbage Collect is executed====\n");
<         mutex_lock(&mem_alloc_lock);
---
> 	DBG("Hardware mapped by %p\n", ctx);
1344,1352c479
< 	for(loop_i = 0; loop_i < G3D_CHUNK_NUM; loop_i++ ){
< 		if((g3d_bootm[loop_i].file_desc_id) == (unsigned int)newid){
< 				if (g3d_bootm[loop_i].in_used == G3D_CHUCNK_RESERVED){
< 		        		s3c_g3d_release_chunk(g3d_bootm[loop_i].phy_addr, g3d_bootm[loop_i].size);
< 				}
< 				g3d_bootm[loop_i].file_desc_id = 0;
< 	        }
<        }
<         mutex_unlock(&mem_alloc_lock);
---
> 	return 0;
1365c492
< 	.name		= "s3c-g3d",
---
> 	.name		= DRIVER_NAME,
1368a496,499
> /*
> 	Platform device operations
> */
> 
1371a503,511
> 	struct g3d_drvdata *data;
> 	int ret;
> 	uint32_t version;
> 
> 	data = kzalloc(sizeof(struct g3d_drvdata), GFP_KERNEL);
> 	if(data == NULL) {
> 		ERR("failed to allocate driver data.\n");
> 		return -ENOMEM;
> 	}
1373,1385c513,515
< 	int		ret;
< 	int		size;
< 	int		i, loop_i;
< 
< 	DEBUG("s3c_g3d probe() called\n");
< 
< #ifdef USE_G3D_DOMAIN_GATING
< 	DOMAIN_POWER_ON;
< #endif /* USE_G3D_DOMAIN_GATING */
< 
< 	g3d_clock = clk_get(&pdev->dev, "hclk_g3d");
< 	if(g3d_clock == NULL) {
< 		printk(KERN_ERR PFX "failed to find post clock source\n");
---
> 	data->clock = clk_get(&pdev->dev, "hclk_g3d");
> 	if (data->clock == NULL) {
> 		ERR("failed to find g3d clock source\n");
1390,1391d519
< 	clk_g3d_enable();
< 
1395c523
< 		printk(KERN_ERR PFX "failed to get memory region resouce\n");
---
> 		ERR("failed to get memory region resource.\n");
1400,1405c528,532
< 	s3c_g3d_base_physical = (unsigned int)res->start;
< 
< 	size = (res->end-res->start)+1;
< 	s3c_g3d_mem = request_mem_region(res->start, size, pdev->name);
< 	if(s3c_g3d_mem == NULL) {
< 		printk(KERN_ERR PFX "failed to reserve memory region\n");
---
> 	/* reserve the memory */
> 	data->mem = request_mem_region(res->start, resource_size(res),
> 								pdev->name);
> 	if (data->mem == NULL) {
> 		ERR("failed to reserve memory region\n");
1410,1412c537,540
< 	s3c_g3d_base = ioremap(res->start, size);
< 	if(s3c_g3d_base == NULL) {
< 		printk(KERN_ERR PFX "failed ioremap\n");
---
> 	/* map the memory */
> 	data->base = ioremap(data->mem->start, resource_size(data->mem));
> 	if (data->base == NULL) {
> 		ERR("ioremap failed\n");
1417,1420c545,549
< 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
< 	if(res == NULL) {
< 		printk(KERN_ERR PFX "failed to get irq resource\n");
< 		ret = -ENOENT;
---
> 	/* get the IRQ */
> 	data->irq = platform_get_irq(pdev, 0);
> 	if (data->irq <= 0) {
> 		ERR("failed to get irq resource (%d).\n", data->irq);
> 		ret = data->irq;
1424,1427c553,556
< 	s3c_g3d_irq = res->start;
< 	ret = request_irq(res->start, s3c_g3d_isr, 0, pdev->name, pdev);
< 	if (ret != 0) {
< 		printk(KERN_ERR PFX "failed to install irq (%d)\n", ret);
---
> 	/* request the IRQ */
> 	ret = request_irq(data->irq, g3d_handle_irq, 0, pdev->name, data);
> 	if (ret) {
> 		ERR("request_irq failed (%d).\n", ret);
1431c560,563
< 	init_waitqueue_head(&waitq);
---
> 	data->owner = NULL;
> 	mutex_init(&data->lock);
> 	mutex_init(&data->hw_lock);
> 	init_completion(&data->completion);
1433,1437c565,573
< 	ret = misc_register(&s3c_g3d_dev);
< 	if (ret < 0) {
< 		printk (KERN_ERR "cannot register miscdev on minor=%d (%d)\n",
< 				G3D_MINOR, ret);
< 		goto err_misc_register;
---
> #ifdef USE_G3D_DOMAIN_GATING
> 	hrtimer_init(&data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
> 	data->timer.function = g3d_idle_func;
> 	data->state = 1;
> #endif
> 	if(g3d_do_power_up(data) < 0) {
> 		ERR("G3D power up failed\n");
> 		ret = -EFAULT;
> 		goto err_pm;
1440,1444c576,578
< #ifdef USE_G3D_DOMAIN_GATING
< 	/* init pm timer */
< 	init_timer(&g3d_pm_timer);
< 	g3d_pm_timer.function = (void*) s3c_g3d_timer;
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	version = g3d_read(data, G3D_FGGB_VERSION);
> 	INFO("detected FIMG-3DSE version %d.%d.%d\n", version >> 24,
> 				(version >> 16) & 0xff, (version >> 8) & 0xff);
1446,1467c580,581
< 	/* device reset */
< 	__raw_writel(1,s3c_g3d_base+FGGB_RST);
< 	for(i=0;i<1000;i++);
< 	__raw_writel(0,s3c_g3d_base+FGGB_RST);
< 	for(i=0;i<1000;i++);
< 
< 	G3D_CHUNK_NUM = G3D_RESERVED_MEM_SIZE /G3D_CHUNK_SIZE;
< 
< 	if (g3d_bootm == NULL)
< 		g3d_bootm = kmalloc(sizeof(s3c_g3d_bootmem) * G3D_CHUNK_NUM, GFP_KERNEL);
< 
< 	printk("s3c_g3d version : 0x%x\n",__raw_readl(s3c_g3d_base + FGGB_VERSION));
< 	printk("G3D_RESERVED_MEM_SIZE : %d MB\n", G3D_RESERVED_MEM_SIZE/SZ_1M);
< 	printk("G3D_CHUNK_SIZE : %d MB\n", G3D_CHUNK_SIZE/SZ_1M);
< 	printk("G3D_CHUNK_NUM : %d (UI_CHUNK:%d)\n", G3D_CHUNK_NUM, G3D_UI_CHUNK_NUM);
< 
< 	for( loop_i = 0; loop_i < G3D_CHUNK_NUM; loop_i++ ){
< 		g3d_bootm[loop_i].vir_addr = (unsigned int)Malloc_3D_ChunkMem(G3D_CHUNK_SIZE, loop_i);
< 		g3d_bootm[loop_i].phy_addr = (unsigned int)virt_to_phys((void*)g3d_bootm[loop_i].vir_addr);
< 		g3d_bootm[loop_i].in_used = G3D_CHUCNK_AVALIABLE;
< 		g3d_bootm[loop_i].size = G3D_CHUNK_SIZE;
< 		g3d_bootm[loop_i].file_desc_id = 0;
---
> 	platform_set_drvdata(pdev, data);
> 	drvdata = data;
1469,1470c583,587
< 		printk("%d th virt_addr = 0x%p, phy_addr = 0x%p\n",
< 			(int)loop_i, (void*)(g3d_bootm[loop_i].vir_addr), (void*)(g3d_bootm[loop_i].phy_addr));
---
> 	ret = misc_register(&s3c_g3d_dev);
> 	if (ret < 0) {
> 		ERR("could not register miscdev on minor=%d (%d)\n",
> 							G3D_MINOR, ret);
> 		goto err_misc_register;
1474,1475c591,594
<         DOMAIN_POWER_OFF;
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	hrtimer_start(&data->timer, ktime_set(G3D_IDLE_TIME_SECS, 0),
> 							HRTIMER_MODE_REL);
> #endif
> 	INFO("Driver loaded succesfully\n");
1477d595
< 	/* check to see if everything is setup correctly */
1481c599,607
< 	free_irq(res->start, pdev);
---
> #ifndef USE_G3D_DOMAIN_GATING
> 	g3d_do_power_down(data);
> #else
> 	if(!hrtimer_cancel(&data->timer))
> 		g3d_power_down(data);
> #endif
> 	free_irq(data->irq, pdev);
> err_pm:
> 	free_irq(data->irq, pdev);
1483c609
< 	iounmap(s3c_g3d_base);
---
> 	iounmap(data->base);
1485,1487c611
<         release_resource(s3c_g3d_mem);
<         kfree(s3c_g3d_mem);
< 	s3c_g3d_mem = NULL;
---
>         release_resource(data->mem);
1489c613
< 	clk_g3d_enable();
---
> 	clk_put(data->clock);
1491,1494c615
< 
< #ifdef USE_G3D_DOMAIN_GATING
< 	DOMAIN_POWER_OFF;
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	kfree(data);
1499c620
< static int s3c_g3d_suspend(struct platform_device *dev, pm_message_t state)
---
> static int s3c_g3d_remove(struct platform_device *pdev)
1501,1509c622
< 	if(g_G3D_CriticalFlag)
< 	{
< 		printk("unexpected Suspend : App don't support suspend-mode.\n");
< 	}
< 	else
< 	{
< 		/*power off*/
< 
< 		clk_g3d_disable();
---
> 	struct g3d_drvdata *data = platform_get_drvdata(pdev);
1512,1513c625,631
< 		DOMAIN_POWER_OFF;
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	if(!hrtimer_cancel(&data->timer))
> 		g3d_power_down(data);
> #else
> 	g3d_flush(data, G3D_FGGB_PIPESTAT_MSK);
> 	g3d_flush_caches(data);
> 	g3d_do_power_down(data);
> #endif
1515,1517c633,640
< 		g_G3D_CriticalFlag=0;
< 		g_G3D_SelfPowerOFF=False;
< 	}
---
> 	misc_deregister(&s3c_g3d_dev);
> 
> 	free_irq(data->irq, data);
> 	iounmap(data->base);
> 	release_resource(data->mem);
> 	kfree(data);
> 
> 	INFO("Driver unloaded succesfully.\n");
1522c645
< static int s3c_g3d_remove(struct platform_device *dev)
---
> static int s3c_g3d_suspend(struct platform_device *pdev, pm_message_t state)
1524,1538c647
< 	free_irq(s3c_g3d_irq, NULL);
< 
< 	if (s3c_g3d_mem != NULL) {
< 		pr_debug("s3c_g3d: releasing s3c_post_mem\n");
< 		iounmap(s3c_g3d_base);
< 		release_resource(s3c_g3d_mem);
< 		kfree(s3c_g3d_mem);
< 	}
< 
< 	if (g3d_bootm != NULL)
< 		kfree(g3d_bootm);
< 
< 	misc_deregister(&s3c_g3d_dev);
< 
< 	clk_g3d_disable();
---
> 	struct g3d_drvdata *data = dev_get_drvdata(&pdev->dev);
1541,1542c650,661
< 	DOMAIN_POWER_OFF;
< #endif /* USE_G3D_DOMAIN_GATING */
---
> 	if(hrtimer_cancel(&data->timer))
> 		g3d_power_down(data);
> #else
> 	g3d_flush(data, G3D_FGGB_PIPESTAT_MSK);
> 	g3d_flush_caches(data);
> 	g3d_do_power_down(data);
> #endif
> 
> 	if (mutex_is_locked(&data->lock)) {
> 		dev_err(data->dev, "suspend requested with locked hardware (broken userspace?)\n");
> 		return -EAGAIN;
> 	}
1543a663
> 	data->owner = NULL;
1548a669,670
> 	struct g3d_drvdata *data = dev_get_drvdata(&pdev->dev);
> 
1550,1555c672,677
<         clk_g3d_enable();
< #endif
< 	if(!g_G3D_CriticalFlag)
< 	{
< 		/*power on 3D PM right after 3D APIs are used*/
< 		g_G3D_SelfPowerOFF=True;
---
> 	
> 	g3d_do_power_up(data);
> 
> 	if(g3d_do_power_up(data) < 0) {
> 		ERR("G3D power up failed\n");
> 		return -EFAULT;
1556a679,682
> #endif
> 	clk_enable(data->clock);
> 	g3d_soft_reset(data);
> 	
1568c694
< 		.name	= "s3c-g3d",
---
> 		.name	= DRIVER_NAME,
1572c698,700
< static char banner[] __initdata = KERN_INFO "S3C G3D Driver, (c) 2007-2009 Samsung Electronics\n";
---
> /*
> 	Module operations
> */
1575a704
> 	int ret;
1577,1581c706,708
< 	printk(banner);
< 	if(platform_driver_register(&s3c_g3d_driver)!=0)
< 	{
< 		printk("platform device register Failed \n");
< 		return -1;
---
> 	if ((ret = platform_driver_register(&s3c_g3d_driver)) != 0) {
> 		ERR("Platform device register failed (%d).\n", ret);
> 		return ret;
1583a711,712
> 	INFO("Module initialized.\n");
> 
1589d717
<     int loop_i;
1592,1604c720
< 	for( loop_i = 0; loop_i < G3D_CHUNK_NUM; loop_i++ ){
< 		Free_3D_ChunkMem((void*)g3d_bootm[loop_i].vir_addr, loop_i);
< 
< 		g3d_bootm[loop_i].vir_addr = 0;
< 		g3d_bootm[loop_i].phy_addr = 0;
< 		g3d_bootm[loop_i].in_used = G3D_CHUCNK_AVALIABLE;
< 		g3d_bootm[loop_i].file_desc_id = 0;
< 		g3d_bootm[loop_i].size = 0;
< 
< //		printk("%d th virt_addr = 0x%p, phy_addr = 0x%p\n", loop_i, (void*)(g3d_bootm[loop_i].vir_addr), (void*)(g3d_bootm[loop_i].phy_addr));
< 	}
< 
< 	printk("S3C G3D module exit\n");
---
> 	INFO("Module exited.\n");
1610c726
< MODULE_AUTHOR("lee@samsung.com");
---
> MODULE_AUTHOR("Tomasz Figa <tomasz.figa@gmail.com>");
1613,1614d728
< 
< 
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.c_0
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.c_2
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.c_current
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.c_good
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.c_tom3qoriginal
Only in ../../qn_orig/Kernel//drivers/media/s3c6410/g3d: s3c_g3d.h
Only in ../../qn_orig/Kernel//drivers/media/s3c6410: g3d_samsung
diff -r ./drivers/misc/pmem.c ../../qn_orig/Kernel//drivers/misc/pmem.c
759a760
> EXPORT_SYMBOL(get_pmem_file);
782a784,785
> EXPORT_SYMBOL(put_pmem_file);
> 
822a826,827
> 
> EXPORT_SYMBOL(flush_pmem_file);
Only in ./include: asm-arm
diff -r ./Makefile ../../qn_orig/Kernel//Makefile
5a6,16
> 
> # *DOCUMENTATION*
> # To see a list of typical targets execute "make help"
> # More info can be located in ./README
> # Comments in this file are targeted only to the developer, do not
> # expect to learn how to build the kernel reading this file.
> 
> # Do not:
> # o  use make's built-in rules and variables
> #    (this increases performance and avoids hard-to-debug behaviour);
> # o  print "Entering directory ...";
7a19,37
> # We are using a recursive build, so we need to do a little thinking
> # to get the ordering right.
> #
> # Most importantly: sub-Makefiles should only ever modify files in
> # their own directory. If in some directory we have a dependency on
> # a file in another dir (which doesn't happen often, but it's often
> # unavoidable when linking the built-in.o targets which finally
> # turn into vmlinux), we will call a sub make in that other dir, and
> # after that we are sure that everything which is in that other dir
> # is now up to date.
> #
> # The only cases where we need to modify files which have global
> # effects are thus separated out and done before the recursive
> # descending is started. They are now explicitly listed as the
> # prepare rule.
> 
> # To put more focus on warnings, be less verbose as default
> # Use 'make V=1' to see the full commands
> 
153a184
> #CROSS_COMPILE   := /home/qnhoang81/buildroot/output/host/usr/bin/arm-unknown-linux-uclibcgnueabi-